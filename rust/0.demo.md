# hello world

```rust
fn main() {
    printfln!("Hello world!");
}
```



# guess_num

```sh
cargo add rand@0.8.5
```



```rust
use rand::Rng;
/**
 * 默认情况下，Rust 设定了若干个会自动导入到每个程序作用域中的标准库内容，这组内容被称为 预导入（prelude） 内容。
 * 可以在标准库文档中查看预导入的所有内容。
 * 如果需要的类型不在预导入内容中，就必须使用 use 语句显式地将其引入作用域。
 * std::io 库提供很多有用的功能，包括接收用户输入的功能。
 */
use std::io;
// 增加了另一个 use 声明，从标准库引入了一个叫做 std::cmp::Ordering 的类型到作用域中。
// Ordering 也是一个枚举，不过它的成员是 Less、Greater 和 Equal。这是比较两个值时可能出现的三种结果。
use std::cmp::Ordering;

fn main() {
    println!("Guess the number!");
    // 调用了 rand::thread_rng 函数提供实际使用的随机数生成器：它位于当前执行线程的本地环境中，并从操作系统获取 seed。
    // 接着调用随机数生成器的 gen_range 方法。这个方法由 use rand::Rng 语句引入到作用域的 Rng trait 定义。
    // gen_range 方法获取一个范围表达式（range expression）作为参数，并生成一个在此范围之间的随机数。
    // 这里使用的这类范围表达式使用了 start..=end 这样的形式，也就是说包含了上下端点，所以需要指定 1..=100 来请求一个 1 和 100 之间的数。[1, 100]
    let secret_number = rand::thread_rng().gen_range(1..=100);
    loop {
        // loop 无限循环
        println!("Please input your number: ");
        // mut表示变量可变
        let mut guess = String::new(); // ::new表示new是String的关联函数

        io::stdin() // 如果没有use std::io, 可以使用 std::io::stdin() 代替 io::stdin()
            // read_line 从标准输入句柄获取用户输入, 返回Result枚举类型, 由于编码处理错误信息, Ok, Err
            // 无论用户在标准输入中键入什么内容，都将其追加（不会覆盖其原有内容）到一个字符串中，因此它需要字符串作为参数
            // &表示传引用, mut &表示传可变引用
            .read_line(&mut guess)
            // Result如果是错误Err, .expect方法会使得程序崩溃
            .expect("fail to read line");

        // Rust 允许用一个新值来遮蔽 （shadow） guess 之前的值。
        // 这允许我们复用 guess 变量的名字，而不是被迫创建两个不同变量，诸如 guess_str 和 guess 之类。
        // String 实例的 trim 方法会去除字符串开头和结尾的空白字符，我们必须执行此方法才能将字符串与 u32 比较，因为 u32 只能包含数值型数据。
        // 字符串的 parse 方法 将字符串解析成数字。因为这个方法可以解析多种数字类型，因此需要告诉 Rust 具体的数字类型，这里通过 let guess: u32 指定。
        // let guess: u32 = guess.trim().parse().expect("input number format err");
        // 使用match处理无效输入
        // 将 expect 调用换成 match 语句，从而实现遇到错误就崩溃转换成处理错误。
        let guess: u32 = match guess.trim().parse() {
            // 如果 parse 能够成功的将字符串转换为一个数字，它会返回一个包含结果数字的 Ok。
            // 这个 Ok 值与 match 第一个分支的模式相匹配，该分支对应的动作返回 Ok 值中的数字 num，最后如愿变成新创建的 guess 变量。
            Ok(num) => num,
            // 如果 parse 不能将字符串转换为一个数字，它会返回一个包含更多错误信息的 Err。
            // Err 值不能匹配第一个 match 分支的 Ok(num) 模式，但是会匹配第二个分支的 Err(_) 
            // 模式：_ 是一个通配符值，本例中用来匹配所有 Err 值，不管其中有何种信息。
            Err(_) => {
                println!("input err, please re input");
                continue;
            }
        };

        // 使用一个 match 表达式，根据对 guess 和 secret_number 调用 cmp 返回的 Ordering 成员来决定接下来做什么。
        // Ordering也是一个枚举, 它的成员是 Less、Greater 和 Equal。
        // 一个 match 表达式由 分支（arms） 构成。一个分支包含一个 模式（pattern）和表达式开头的值与分支模式相匹配时应该执行的代码。
        // Rust 获取提供给 match 的值并挨个检查每个分支的模式。match 结构和模式是 Rust 中强大的功能，它体现了代码可能遇到的多种情形，并帮助你确保没有遗漏处理。
        match guess.cmp(&secret_number) {
            Ordering::Less => println!("too small"),
            Ordering::Greater => println!("too big"),
            Ordering::Equal => {
                println!("You win");
                break;
            }
        }
    }
}
```

