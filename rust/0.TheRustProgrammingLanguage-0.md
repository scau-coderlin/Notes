官方教程，rust权威指南。



# 简介

开发工具：

- Cargo 是内置的依赖管理器和构建工具，它能轻松增加、编译和管理依赖，并使依赖在 Rust 生态系统中保持一致。
- Rustfmt 格式化工具确保开发者遵循一致的代码风格。
- Rust Language Server 为集成开发环境（IDE）提供了强大的代码补全和内联错误信息功能。

使用场景：

- 命令行工具，网页应用，网络服务，嵌入式开发。

rust编写的软件：

1. redox操作系统
2. Linux内核正在加入用rust语言写驱动和模块的支持。
3. rcore教学操作系统。



# 1 入门指南

## 1.1 安装

> 参考rust官网

由于国内使用linux系统按照官网安装rust的话，其网速下载较慢，这里推荐使用字节跳动的rust镜像代理进行安装。

网址： `https://rsproxy.cn/`

```sh
# 步骤一：设置 Rustup 镜像， 修改配置 ~/.zshrc or ~/.bashrc
vim ~/.bashrc
# 在文件末尾添加以下内容
export RUSTUP_DIST_SERVER="https://rsproxy.cn"
export RUSTUP_UPDATE_ROOT="https://rsproxy.cn/rustup"

# 步骤二：安装 Rust（请先完成步骤一的环境变量导入并 source rc 文件或重启终端生效）
curl --proto '=https' --tlsv1.2 -sSf https://rsproxy.cn/rustup-init.sh | sh

# 步骤3, 可选
# 设置 crates.io 镜像， 修改配置 ~/.cargo/config.toml，已支持git协议和sparse协议，>=1.68 版本建议使用 sparse-index，速度更快。
# 该文件可能不存在, 直接创建并写入以下内容即可
# 该配置可应用至windows系统
vim ~/.cargo/config.toml
# 将以下内容写入该文件, 如果该文件已存在, 覆盖内容
[source.crates-io]
replace-with = 'rsproxy-sparse'
[source.rsproxy]
registry = "https://rsproxy.cn/crates.io-index"
[source.rsproxy-sparse]
registry = "sparse+https://rsproxy.cn/index/"
[registries.rsproxy]
index = "https://rsproxy.cn/crates.io-index"
[net]
git-fetch-with-cli = true
```



## 1.2 Hello World

```rust
fn main() {
    println!("Hello World!");
}
```



简单编译

```sh
rustc main.rs
```



## 1.3 Hello Cargo

```sh
# 创建项目
cargo new hello_cargo

# 不生成 git 仓库
cargo new hello_cargo_no_git --vcs=git

cd hello_cargo

# 构建
cargo build

# 构建发行版
cargo build --release

# 运行
cargo run

# 代码检查
cargo check
```



# 2 写个猜数字游戏

## match匹配

1. 匹配语句由一个表达式 `ex` 和一组 `val => exp` 的分支语句组成。
2. 整个匹配语句被视为一个表达式来求值；此时，所有分支都必须是相同类型的值。
3. 下划线 `_` 用于捕捉所有情况。类似于 `c++` 的 `default`。

```rust
let x = 3;
match x {
    1 => println!("one"),
    2 => {
    	println!("tow");
        println!("tow");
    },
    _ => println!("no"),
}
```



4. 匹配的表达式（`match ex`）可以是任意表达式，包括元组和函数调用。
	1. 构成模式。
	2. 匹配可以绑定变量，`_` 用来忽略不需要的部分。
5. 为了通过编译，必须穷尽所有匹配模式。
6. 可以用 `if` 来限制匹配的条件。

```rust
let x = 3;
let y = -3;
match (x, y) {
    (1, 1) => println!("one"),
    (2, j) => println!("tow, {}", j),
    (_, 3) => println!("three"),
    (i, j) if i > 5 && j < 0 => println!("On guard"),
    (_, _) => println!(":<"),
}
```



## cargo config

```sh
cargo new guessing_game

cd guess_game

cargo add rand@0.8.5
```



## code

```rust
use rand::Rng;
/**
 * 默认情况下，Rust 设定了若干个会自动导入到每个程序作用域中的标准库内容，这组内容被称为 预导入（prelude） 内容。
 * 可以在标准库文档中查看预导入的所有内容。
 * 如果需要的类型不在预导入内容中，就必须使用 use 语句显式地将其引入作用域。
 * std::io 库提供很多有用的功能，包括接收用户输入的功能。
 */
use std::io;
// 增加了另一个 use 声明，从标准库引入了一个叫做 std::cmp::Ordering 的类型到作用域中。
// Ordering 也是一个枚举，不过它的成员是 Less、Greater 和 Equal。这是比较两个值时可能出现的三种结果。
use std::cmp::Ordering;

fn main() {
    println!("Guess the number!");
    // 调用了 rand::thread_rng 函数提供实际使用的随机数生成器：它位于当前执行线程的本地环境中，并从操作系统获取 seed。
    // 接着调用随机数生成器的 gen_range 方法。这个方法由 use rand::Rng 语句引入到作用域的 Rng trait 定义。
    // gen_range 方法获取一个范围表达式（range expression）作为参数，并生成一个在此范围之间的随机数。
    // 这里使用的这类范围表达式使用了 start..=end 这样的形式，也就是说包含了上下端点，所以需要指定 1..=100 来请求一个 1 和 100 之间的数。[1, 100]
    let secret_number = rand::thread_rng().gen_range(1..=100);
    loop {
        // loop 无限循环
        println!("Please input your number: ");
        // mut表示变量可变
        let mut guess = String::new(); // ::new表示new是String的关联函数

        io::stdin() // 如果没有use std::io, 可以使用 std::io::stdin() 代替 io::stdin()
            // read_line 从标准输入句柄获取用户输入, 返回Result枚举类型, 由于编码处理错误信息, Ok, Err
            // 无论用户在标准输入中键入什么内容，都将其追加（不会覆盖其原有内容）到一个字符串中，因此它需要字符串作为参数
            // &表示传引用, mut &表示传可变引用
            .read_line(&mut guess)
            // Result如果是错误Err, .expect方法会使得程序崩溃
            .expect("fail to read line");

        // Rust 允许用一个新值来遮蔽 （shadow） guess 之前的值。
        // 这允许我们复用 guess 变量的名字，而不是被迫创建两个不同变量，诸如 guess_str 和 guess 之类。
        // String 实例的 trim 方法会去除字符串开头和结尾的空白字符，我们必须执行此方法才能将字符串与 u32 比较，因为 u32 只能包含数值型数据。
        // 字符串的 parse 方法 将字符串解析成数字。因为这个方法可以解析多种数字类型，因此需要告诉 Rust 具体的数字类型，这里通过 let guess: u32 指定。
        // let guess: u32 = guess.trim().parse().expect("input number format err");
        // 使用match处理无效输入
        // 将 expect 调用换成 match 语句，从而实现遇到错误就崩溃转换成处理错误。
        let guess: u32 = match guess.trim().parse() {
            // 如果 parse 能够成功的将字符串转换为一个数字，它会返回一个包含结果数字的 Ok。
            // 这个 Ok 值与 match 第一个分支的模式相匹配，该分支对应的动作返回 Ok 值中的数字 num，最后如愿变成新创建的 guess 变量。
            Ok(num) => num,
            // 如果 parse 不能将字符串转换为一个数字，它会返回一个包含更多错误信息的 Err。
            // Err 值不能匹配第一个 match 分支的 Ok(num) 模式，但是会匹配第二个分支的 Err(_) 
            // 模式：_ 是一个通配符值，本例中用来匹配所有 Err 值，不管其中有何种信息。
            Err(_) => {
                println!("input err, please re input");
                continue;
            }
        };

        // 使用一个 match 表达式，根据对 guess 和 secret_number 调用 cmp 返回的 Ordering 成员来决定接下来做什么。
        // Ordering也是一个枚举, 它的成员是 Less、Greater 和 Equal。
        // 一个 match 表达式由 分支（arms） 构成。一个分支包含一个 模式（pattern）和表达式开头的值与分支模式相匹配时应该执行的代码。
        // Rust 获取提供给 match 的值并挨个检查每个分支的模式。match 结构和模式是 Rust 中强大的功能，它体现了代码可能遇到的多种情形，并帮助你确保没有遗漏处理。
        match guess.cmp(&secret_number) {
            Ordering::Less => println!("too small"),
            Ordering::Greater => println!("too big"),
            Ordering::Equal => {
                println!("You win");
                break;
            }
        }
    }
}
```



# 3 常见编程概念

## 3.1 变量与可变性

### 变量

1. **变量默认是不可变的** `immutable`。
2. 如果需要让变量可变，需要使用 `mut` 进行修饰。
3. 如果变量没有用到可以用前置下划线消除警告。
4. 在使用大型数据结构的情形下，在同一位置更改实例可能比复制并返回新分配的实例要更快。
5. 使用较小的数据结构时，通常创建新的实例并以更具函数式编程的风格来编写程序，可能会更容易理解，**所以值得以较低的性能开销来确保代码清晰**。



**let**：

> 用于创建变量的关键字

```rust
let guess = String::new(); // 创建字符串变量
```



**mut**：

> 设置变量的属性为可变变量。

```rust
let mut guess = String::new();
```



### 常量

> const常量

1. 与不可变变量类似，**常量**（*constant*）是绑定到一个常量名且不允许更改的值，但是常量和变量之间存在一些差异：
	1. 常量不允许使用 `mut`。常量不仅仅默认不可变，而且自始至终不可变。**常量使用 `const` 关键字而不是 `let` 关键字来声明，并且值的类型必须注明**。
	2. 常量可以在任意作用域内声明，包括全局作用域，这对于代码中很多部分都需要知道一个值的情况特别有用。
	3. 最后一个不同点是常量只能设置为常量表达式，而不能是函数调用的结果或是只能在运行时计算得到的值。

2. **常量的值必须是编译时已知的常量表达式**，必须指定类型与值。值可以为字面值常量或者常量表达式。
3. 与C语言的宏定义（宏替换）不同，rust的const常量的值被直接嵌入到生成的底层机器代码中，而不是进行简单的字符替换。
4. 命名建议全部大写，单词之间加入下划线。
5. **常量的作用域是块级（花括号）作用域**，它们只在声明它们的作用域内可见，在声明的作用域内，常量在程序运行的整个过程中都有效。
6. 对于应用程序域中程序的多个部分可能都需要知道的值的时候，常量是一个很有用的选择。
7. 将整个程序中用到的硬编码（hardcode）值命名为常量，对于将该值的含义传达给代码的未来维护者很有用。如果将来需要更改硬编码的值，则只需要在代码中改动一处就可以了

```rust
// 相当于C++的constexpr
// 格式: const NAME : TYPE = VALUE;
const MAX_POINTS: u32 = 10_0000;
const THREE_HOURS_IN_SECONDS: u32 = 60 * 60 * 3;
```



### 隐藏

1. 允许同一作用域下，声明一个与现有变量同名的新变量，上一个会被隐藏。
2. **可以改变值，可以改变类型，可以改变可变性**。

```rust
fn main() {
    // 这个程序首先将数值 5 绑定到 x。
    let x = 5;

    // 然后通过重复使用 let x = 来遮蔽之前的 x，并取原来的值加上 1，所以 x 的值变成了 6。
    let x = x + 1;

    {
        // 在内部作用域内，第三个 let 语句同样遮蔽前面的 x，取之前的值并乘上 2，得到的 x 值为 12。
        let x = x * 2;
        println!("The value of x in the inner scope is: {}", x);
    }

    // 当该作用域结束时，内部遮蔽结束并且 x 恢复成 6。
    println!("The value of x is: {}", x);
}
```



## 3.2 数据类型

1. rust是静态类型语言，故每个值都属于某一个数据类型。
2. 包括数据标量和复合。
3. Rust 的所有数字类型都支持基本数学运算：加法、减法、乘法、除法和取模运算。整数除法会向下取整。



### 标量类型

1. Rust 有 4 个基本的标量类型：整型、浮点型、布尔型和字符。

#### 整型

| 长度   | 有符号类型 | 无符号类型 | 备注                                                         |
| ------ | ---------- | ---------- | ------------------------------------------------------------ |
| 8 位   | `i8`       | `u8`       |                                                              |
| 16 位  | `i16`      | `u16`      |                                                              |
| 32 位  | `i32`      | `u32`      | 整数默认类型，当不指定数据类型时的整数默认类型               |
| 64 位  | `i64`      | `u64`      |                                                              |
| 128 位 | `i128`     | `u128`     |                                                              |
| arch   | `isize`    | `usize`    | 取决于程序运行的计算机体系结构，和计算机架构相同, 如32位计算机为32-bit, 64位计算机为64-bit；数组下标必须为 `usize`，和指针大小等大。 |

```rust
// 可以使用字面量带后缀来限定类型
let i = 32_i32;

// 字节, 仅可用于u8
let byte = b'A';

// 十进制
let a1 = 125;
// 十六进制
let a2 = 0xFF;
// 八进制
let a3 = 0o13;
// 二进制
let a4 = 0b10;

// 打印最大值
// 使用 TYPE::MAX
println!("u32 max: {}", u32::MAX);

// 打印所占字节数, 相当于c的sizeof()
println!("isize is {} bytes", std::mem::size_of::<isize>());
```



显式处理溢出可以使用标准库针对原始数字类型提供的以下一系列方法：

- 使用 `wrapping_*` 方法在所有模式下进行包裹，例如 `wrapping_add`
- 如果使用 `checked_*` 方法时发生溢出，则返回 `None` 值
- 使用 `overflowing_*` 方法返回该值和一个指示是否存在溢出的布尔值
- 使用 `saturating_*` 方法使值达到最小值或最大值



#### 浮点型

```rust
// 32位浮点数
f32

// 64位浮点数
f64 // 默认, 建议使用

// 打印时四舍五入
println!("Float are {:2}", f); // 以四舍五入的方式保留两位小数
```



#### 数值运算

Rust中所有的数学类型都支持基本的数学运算：加法、减法、乘法、除法和取余



#### 布尔类型

```rust
bool // true/false
```



#### 字符型

1. Rust 的字符类型大小为 4 个字节，表示的是一个 Unicode 标量值

```rust
char // 大小为4字节, unicode
```



### 复合类型

1. rust有两个原生的复合类型：元组和数组。

#### 元组

1. 元组是将多种类型的多个值组合到一个复合类型中的一种基本方式。
2. **元组的长度是固定的**：声明后，它们就无法增长或缩小。
3. 我们通过在小括号内写入以逗号分隔的值列表来创建一个元组。**元组中的每个位置都有一个类型，并且元组中不同值的类型不要求是相同的**。
4. **想从元组中获取个别值，我们可以使用模式匹配来解构（destructure）元组的一个值**。也可以通过下标来访问元组的分量。
5. 元组中的第一个索引为 0。
6. 没有任何值的元组 `()` 是一种特殊的类型，及单元元组（unit），只有一个值，也写成 `()`。该类型被称为**单元类型**（*unit type*），该值被称为**单元值**（*unit value*）。如果表达式不返回任何其他值，就隐式地返回单元值。

```rust
// 圆括号, 类型1, 类型2...
// (type1, type2, type3)
(i32, f64, u8)

// 访问, 通过元素索引位置进行访问
let tup = (8_i32, 1.6_f64, b'A');
println!("{},{},{}", tup.0, tup.1, tup.2);

// 解构
// 解析到单个变量中, 利用模式匹配
// 相当于 x = tup.0, y = tup.1, z = tup.2
// 借助 let 来使用一个模式匹配 tup，并将它分解成三个单独的变量 x、y 和 z。
let (x, y, z) = tup;
```



#### 数组

1. 数组的每个元素必须具有相同的类型。
2. Rust 中的数组具有固定长度。
3. 分配在栈上而不是堆上。
4. 使用方括号编写数组的类型，其中包含每个元素的类型、分号，然后是数组中的元素数。
5. 如果要为每个元素创建包含相同值的数组，可以指定初始值，后跟分号，然后在方括号中指定数组的长度。
6. **当你尝试使用索引访问元素时，Rust 将检查你指定的索引是否越界**。如果索引大于或等于数组长度，Rust 会出现 `panic`，并立即退出。

```rust
// 类型 [type; max_elem_num]
// 使用方括号编写数组的类型，其中包含每个元素的类型、分号，然后是数组中的元素数。
let arr: [i32; 64]; // 相当于c++的: int arr[64];

// 如果要为每个元素创建包含相同值的数组，可以指定初始值，后跟分号，然后在方括号中指定数组的长度
let arr1 = [0; 64]; // 64个元素的数组, 每个数组元素的值被初始化为0, int arr1[64] = {0};
// 等价于
let arr1 = [0i32, 64]; // 实际上是类型 [type; max_elem_num]的一种变形。

let arr2 = [1, 2, 3, 4, 5]; // int arr[] = {1, 2, 3, 4, 5};

// 访问:
println!("{}", arr[0]);
```



越界错误信息：

```sh
thread 'main' panicked at src/main.rs:17:35:
index out of bounds: the len is 5 but the index is 5
note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace
```



## 3.3 函数

1. 关键字 `fn`，`rust` 使用关键字 `fn` 声明新函数。
2. Rust 中的函数定义以 `fn` 开始，后跟着函数名和一对圆括号。大括号告诉编译器函数体在哪里开始和结束。
3. 可以使用函数名后跟圆括号来调用我们定义过的任意函数。
4. **Rust 不关心函数定义于何处，只要定义了就行**。
5. rust 规定必须显示定义函数的参数和返回值的类型。

```rust
fn main() {
    println!("Hello, world!");
    another_func();
}

// another_function 定义在 main 函数之后；也可以定义在之前。
fn another_func() {
    println!("in another func");
}
```



### 参数

1. 函数也可以被定义为拥有**参数**（*parameter*），参数是特殊变量，是函数签名的一部分。
2. 当函数拥有参数（形参）时，可以为这些参数提供具体的值（实参）。技术上讲，这些具体值被称为**实参**（*argument*）。
3. 在函数签名中，**必须**声明每个参数的类型。
4. 当一个函数有多个参数时，使用逗号分隔

```rust
fn main() {
    println!("Hello, world!");
    another_func(5, 6);
}

fn another_func(x: i32, y: i32) {
    println!("in another func, x = {x}, y = {y}");
}

// 引用参数
fn test(x: &mut i32) {
    *x = 5;
}
```



### 语句和表达式

> 实际上语句可以看成是一个特殊表达式，类型是void，或者说是单位元。

1. 变量声明绑定不是表达式。
2. 单位元 ( unit ) 类型，表示空，写作 `()`。
	1. 类型 `()` 只有一个可取的值：`()`。
	2. `()` 是默认的返回类型。

3. 函数体由一系列语句组成，也可选择以表达式结尾。
4. **语句**（*statement*）是执行一些操作但不返回值的指令。表达式（*expression*）计算并产生一个值。
5. 代码块的值是其最后一个表达式的值。

```rust
let x = 6; // 语句
let x = (let y = 6); //err, let y = 6, 是语句, 不返回值, 无法赋予 x, [expected expression, found statement]
```



4. 函数调用是一个表达式。
5. 宏调用是一个表达式。
6. 用来创建新作用域的大括号（代码块） `{}` 也是一个表达式。
7. 表达式的结尾没有分号。如果在表达式的末尾加上分号，那么它就转换为语句，而语句返回的是 `()`。

```rust
fn main() {
    let y = {
        let x = 4;
        // 注意，x + 1 行的末尾没有分号，这与你目前见过的大部分代码行不同。
        // 表达式的结尾没有分号。如果在表达式的末尾加上分号，那么它就转换为语句，而语句不会返回值。
        x + 1
    };
    println!("y = {}", y); // 5
}
```



8. 由于基本上所有东西都是表达式，因此都可以绑定到变量

```rust
let mut x = -5;
let y = if x > 0 {
    "greater"
} else {
    "less"
};
let z = loop {
    x += 10;
    if (x > 5) {
        break x;
    }
};
```



### 具有返回值的函数

1. 在箭头（`->`）后声明它的返回值类型。
2. 在 Rust 中，函数的返回值等同于函数体最后一个表达式的值。
3. 使用 `return` 关键字和指定值，可以从函数中提前返回；但**大部分函数隐式返回最后一个表达式**。

``` rust
fn five() -> i32 {
    // 表达式的结尾没有分号。如果在表达式的末尾加上分号，那么它就转换为语句，而语句不会返回值。
    // 如果在包含 5 的行尾加上一个分号，把它从表达式变成语句，将得到一个错误。[“mismatched types”（类型不匹配）]
    5
    // 或
    return 5;
}
```



## 3.4 注释

1. 普通注释

```rust
//
/**/
```



2. 文档注释，三个 `/` 开头的行注释为文档字符串注释。



## 3.5 控制流

1. 根据条件是否为真来决定是否执行某些代码，或根据条件是否为真来重复运行一段代码



### if 表达式

> 和 C++ 不同，条件部分不需要用小括号括起来。

1. `if` 表达式允许根据条件执行不同的代码分支。你提供一个条件并表示 “如果条件满足，运行这段代码；如果条件不满足，不运行这段代码。”
1. 所有的 `if` 表达式都以 `if` 关键字开头，其后跟一个条件。条件**必须**是 `bool` 值。
1. 条件表达式无需放在圆括号里（和C/C++不同的地方）。
1. Rust 并不会尝试自动地将非布尔值转换为布尔值。必须自始至终显式地使用布尔值作为 `if` 的条件。
1. 也可以包含一个可选的 `else` 表达式来提供一个在条件为假时应当执行的代码块，如果不提供 `else` 表达式并且条件为假时，程序会直接忽略 `if` 代码块并继续执行下面的代码



#### 使用 else if 处理多重条件

1. 可以将 `if` 和 `else` 组成的 `else if` 表达式来实现多重条件。
1. Rust 只会执行第一个条件为真的代码块，并且一旦它找到一个以后，不会检查剩下的条件了。

```rust
fn main() {
    let number = 3;

    if number < 5 {
        println!("condition was true");
    } else {
        println!("condition was false");
    }
}
```



#### 在let语句中使用if

1. **`if` 是一个表达式，我们可以在 `let` 语句的右侧使用它来将结果赋值给一个变量**；此时，每个分支都必须是相同类型的表达式。
2. 代码块的值是其最后一个表达式的值。
3. 整个 `if` 表达式的值取决于哪个代码块被执行。意味着 `if` 的每个分支的可能的返回值都必须是相同类型。

```rust
fn main() {
    let condition = true;
    // 代码块的值是其最后一个表达式的值，而数字本身就是一个表达式。
    let number = if condition {
        5 // 不能有分号，否则变成语句
    } else {
        6
    };

    println!("The value of number is: {}", number);
}
```



### 使用循环重复执行

#### 使用loop 重复执行代码 

1. `loop` 关键字告诉 Rust 一遍又一遍地执行一段代码直到你明确要求停止。相当于 `while (true)`。
2. 如果存在嵌套循环，`break` 和 `continue` 应用于此时最内层的循环

```rust
fn main() {
    let mut x = 3;
    loop {
        println!("Hello");
        x -= 1; // rust不支持--运算符
        if x == 0 {
            break;
        }
    }
}
```

##### 从循环返回值

1. **可以在用于停止循环的 `break` 表达式添加你想要返回的值；该值将从循环中返回。另外两种循环没有这个功能**。

```rust
fn main() {
    let mut counter = 0;

    let result = loop {
        counter += 1;

        if counter == 10 {
            break counter * 2;
        }
    };

    println!("The result is {}", result);
}
```



##### 循环标签：在多个循环之间消除歧义

1. 存在嵌套循环时，可以选择在一个循环上指定一个**循环标签**（*loop label*），然后将标签与 `break` 或 `continue` 一起使用，使这些关键字应用于已标记的循环而不是最内层的循环。

2. 循环标签格式为：`'label_name:`，`break 'label name` 退出外层循环。

```rust
fn main() {
    let mut count = 0;
    // 外层循环有一个标签 counting_up，它将从 0 数到 2。
    // 没有标签的内部循环从 10 向下数到 9。
    // 第一个没有指定标签的 break 将只退出内层循环。break 'counting_up; 语句将退出外层循环。
    'counting_up: loop {
        println!("count = {}", count);
        let mut remaining = 10;

        loop {
            println!("remaining = {}", remaining);
            if remaining == 9 {
                break;
            }
            if count == 2 {
                break 'counting_up;
            }
            remaining -= 1;
        }

        count += 1;
    }
    println!("End count = {}", count);
}

```



#### while 条件循环

```rust
fn main() {
    let mut number = 3;

    while number != 0 {
        println!("{}!", number);

        number -= 1;
    }

    println!("LIFTOFF!!!");
}
```



#### 使用for遍历循环

1. 可用于循环遍历集合中的元素。

```rust
fn main() {
    let a = [10, 20, 30, 40, 50];

    for element in a {
        println!("the value is: {}", element);
    }
}
```



2. 可以结合 `Range` 实现类似与 `C/C++` 的 `for (int i = 0; i < size; i++)`。

```rust
fn main() {
    for i in 0..=10 {	// for (int i = 0; i <= 10; i++)
        println!("i = {i}");
    }
    
    for i in 0..10 {	// for (int i = 0; i < 10; i++)
        println!("i = {i}");
    }
}
```



# 4 认识所有权

所有权（系统）是 Rust 最为与众不同的特性，它让 Rust 无需垃圾回收器（garbage collector）即可保证内存安全。



## 4.1 什么是所有权？

1. **所有权是 Rust 用于如何管理内存的一组规则**；在编译时确定。

2. 所有运行的程序都必须管理其运行时使用计算机内存的方式。一些语言中具有垃圾回收机制（Java），在程序运行时不断地寻找不再使用的内存；在另一些语言中，开发者必须亲自分配和释放内存（C/C++）。

	Rust 则选择了第三种方式：通过所有权系统管理内存，**编译器在编译时会根据一系列的规则进行检查**。在运行时，所有权系统的任何功能都不会减慢程序。

3. 跟踪哪部分代码正在使用堆上的哪些数据，最大限度地减少堆上的重复数据量，以及清理堆上不再使用的数据确保不会耗尽空间，这些问题正是所有权系统要处理的。所有权的主要目的就是管理堆数据。



### 所有权规则

1. Rust 中的每一个值都有一个被称为其 **所有者**（*owner*）的变量。
2. **值在任一时刻有且只有一个所有者**。
3. 当所有者（变量）离开作用域，这个值将被丢弃：当变量离开作用域时，`rust` 自动调用 `drop` 函数释放内存代码。`C++` 中可通过 `RAII` 实现。



### 变量作用域

```rust
fn main() {
    // 变量 s 绑定到了一个字符串字面量，
    // 这个字符串值是硬编码进程序代码中的。
    // 该变量从声明的那一刻开始直到当前 作用域 结束时都是有效的
    let s = "Hello";
}
```



### String类型

> 只专著String与所有权有关的部分。

1. String是一个标准库提供的字符串类型，它是 UTF-8 编码的可增长文本块。
2. 这个类型管理被分配到堆上的数据，所以能够存储在编译时未知大小的文本。

```rust
let mut s = String::from("Hello");
p.push_str(", world");	// 追加字符串
```



### 内存与分配

1. String类型支持一个可变，可增长的文本片段：
	1. 必须在运行时向内存分配器 `memory allocator` 申请内存：由程序员自行申请。`::new` / `::from`...
	2. 需要一个当处理完 `String` 时将内存返回给分配器的方法：**所有权机制**-在变量离开作用域后自动释放；当变量离开作用域时，`rust` 自动调用 `drop` 函数释放内存代码。



##### 变量与数据交互的方式（一）：移动

1. 赋值运算符 `=`，对于堆数据（`Drop`）变量而言，`rust` 永远不会自动创建数据的深拷贝；而是移动语义。

```rust
// 为了防止二次释放
// rust 对持有堆上数据的变量, = 操作符默认为移动
let s = String::from("Hello");
let s2 = s; // 此时s的所有权被移动至s2, s无效, 后续使用将无法通过编译
```



##### 变量与数据交互的方式（二）：克隆

```rust
// // rust 对持有堆上数据的变量, 深拷贝需使用成员函数 - 克隆函数
.clone();
```



##### 只在栈上的数据：拷贝

1. Rust 有一个叫做 `Copy` trait 的特殊注解，可以用在类似整型这样的存储在栈上的类型上。如果一个类型实现了 `Copy` trait，那么一个旧的变量在将其赋值给其他变量后仍然可用。
2. Rust 不允许自身或其任何部分实现了 `Drop` trait 的类型使用 `Copy` trait。如果我们对其值离开作用域时需要特殊处理的类型使用 `Copy` 注解，将会出现一个编译时错误。
3. 一般来说，包含堆数据的变量一般拥有 `Drop` trait的特殊注解。
4. 包含 `Copy train` 的特殊注解的变量，其赋值一般为复制；而包含 `Drop train` 的特殊注解的变量，其赋值一般为移动。
5. 一些实现了 `Copy` 的类型：
	1. 整数类型。
	1. 布尔类型。
	1. 浮点数类型。
	1. 字符类型。
	1. 元组，当且仅当其包含的类型都实现 `Copy` 的时候。



### 所有权与函数

1. 将值传递给函数与给变量赋值的原理相似。向函数传递值可能会移动或复制。

```rust
fn main() {
    let s = String::from("hello");  // s 进入作用域

    takes_ownership(s);             // s 的值移动到函数里 ...
                                    // ... 所以到这里不再有效
    // 当尝试在调用 takes_ownership 后使用 s 时，Rust 会抛出一个编译时错误。

    let x = 5;                      // x 进入作用域

    makes_copy(x);                  // x 应该移动函数里，
                                    // 但 i32 是 Copy 的，
                                    // 所以在后面可继续使用 x

} // 这里，x 先移出了作用域，然后是 s。但因为 s 的值已被移走，
  // 没有特殊之处

fn takes_ownership(some_string: String) { // some_string 进入作用域
    println!("{}", some_string);
} // 这里，some_string 移出作用域并调用 `drop` 方法。
  // 占用的内存被释放

fn makes_copy(some_integer: i32) { // some_integer 进入作用域
    println!("{}", some_integer);
} // 这里，some_integer 移出作用域。没有特殊之处
```



### 返回值与作用域

1. 返回值也可以转移所有权
2. 变量的所有权总是遵循相同的模式：将值赋给另一个变量时移动它。当持有堆中数据值的变量离开作用域时，其值将通过 `drop` 被清理掉，除非数据被移动为另一个变量所有。

```rust
fn main() {
    let s1 = gives_ownership();         // gives_ownership 将返回值
                                        // 转移给 s1

    let s2 = String::from("hello");     // s2 进入作用域

    let s3 = takes_and_gives_back(s2);  // s2 被移动到
                                        // takes_and_gives_back 中，
                                        // 它也将返回值移给 s3
} // 这里，s3 移出作用域并被丢弃。s2 也移出作用域，但已被移走，
  // 所以什么也不会发生。s1 离开作用域并被丢弃

fn gives_ownership() -> String {             // gives_ownership 会将
                                             // 返回值移动给
                                             // 调用它的函数

    let some_string = String::from("yours"); // some_string 进入作用域。

    some_string                              // 返回 some_string 
                                             // 并移出给调用的函数
                                             // 
}

// takes_and_gives_back 将传入字符串并返回该值
fn takes_and_gives_back(a_string: String) -> String { // a_string 进入作用域
                                                      // 

    a_string  // 返回 a_string 并移出给调用的函数
}
```



## 4.2 引用与借用

1. 引用和变量一样，默认是不可变的。
2. 引用像一个指针，因为它是一个地址，可以由此访问存储于该地址属于其他变量的数据。和指针不同的是，rust的引用确保指向某个特定类型的有效值。不会成为悬垂指针。
3. 在类型前面写 `&` 表示引用类型。
4. 用 `&` 来取引用，允许使用值但不获得其所有权。
5. 用 `*` 来解引用。
6. 借用：创建一个引用的行为。

```rust
fn main() {
    let x = 12;
    let ref_x = &x;
    println!("{}", *ref_x);
}

// 函数入参引用
fn calculate_length(s: &String) -> usize {
    // 变量 s 有效的作用域与函数参数的作用域一样，不过当 s 停止使用时并不丢弃引用指向的数据，因为 s 并没有所有权
    return s.len();
}
```



### 可变引用

1. 加上 `mut` 修饰。`&mut s` ，`s: &mut String` 。 

2. 如果有一个对该变量的可变引用，就不能再创建对该变量的引用；防止同一时间对同一数据存在多个可变引用，从而造成数据竞争。

3. 数据竞争可由3个行为造成：

	1. 两个或更多指针同时访问同一数据。

	2. 至少有一个指针被用来写入数据。

	3. 没有同步数据访问的机制。

4. 可以使用大括号来创建一个新的作用域，以允许拥有多个可变引用，只是不能 **同时** 拥有。

```rust
// 函数入参可变引用: valname: &mut type
fn test(x: &mut i32) {
    *x = 5;
}

// 如果有一个对该变量的可变引用，就不能再创建对该变量的引用。
fn main() {
    let mut s = String::from("hello");

    let r1 = &mut s;
    let r2 = &mut s; // err, 不能在同一时间多次将 s 作为可变变量借用
    println!("{}, {}", r1, r2);

}
```



5. 不能在拥有不可变引用的同时拥有可变引用，即不能同时拥有可变引用和不可变引用。多个不可变引用是可以的。

```rust
fn main() {
	let mut s = String::from("hello");

    let r1 = &s; // 没问题
    let r2 = &s; // 没问题
    println!("{} and {}", r1, r2);
    // 此位置之后 r1 和 r2 不再使用

    let r3 = &mut s; // 没问题, 作用域没有重叠
    println!("{}", r3);
}
```



#### 悬垂引用

1. 所谓悬垂指针是其指向的内存可能已经被分配给其他持有者。
2. rust编译器保证引用永远不会变成悬垂状态。



#### 引用的规则

1. 在任意给定时间，**要么** 只能有一个可变引用，**要么** 只能有多个不可变引用。
2. 引用必须总是有效的。



## 4.3 Slice类型

1. slice 允许引用集合中一段连续的元素序列，而不用引用整个集合。
2. 切片类型的形式为 `&[T]`，例如 `&[i32]`。
3. 切片表示引用数组中的一部分所形成的视图。
4. 切片不能直接创建，需要从别的变量借用。
5. 切片可以是可变的，也可以是不可变的。



#### 字符串slice

1. `&srt` 可以看成是 `String` 的切片类型，是String中一部分值的引用。

```rust
fn main() {
    // 双冒号（::）运算符允许我们将特定的 from 函数置于 String 类型的命名空间（namespace）下，而不需要使用类似 string_from 这样的名字
	let _s = String::from("hello world");
    let hello = &s[0..5];
    let world = &s[6..11];
}
```



2. 如果想要从索引0开始，可以不写两个点之前的值。
3. 字符串 slice range 的索引必须位于有效的 UTF-8 字符边界内，如果尝试从一个多字节字符的中间位置创建字符串 slice，则程序将会因错误而退出。
4. 字符串的字面值就是slice。

```rust
fn main() {
    let s1 = "hello world";
    println!("first s1 = {}", first_world(s1));
    let s2 = String::from("aaa bbb");
    println!("first s2 = {}", first_world(&s2));
}

fn first_world(s: &str) -> &str {
    let bytes = s.as_bytes(); // 将String转化为字节数组

    // .iter() 迭代器, 
    // .enumerate() 包装 .iter() 结果为一个元组
    // .enumerate() 返回索引, 元素引用
    for (i, &item) in bytes.iter().enumerate() {
        if item == b' ' {
            return &s[..i];
        }
    }
    return &s[..];
}
```



#### 其他类型的slice

```rust
let arr = [0, 1, 2, 4, 5];
let total_slice = &arr;
let total_slice = &arr[..];
let partial_slice = &arr[2..5];
```



# 5 使用结构体组织相关联的数据

1. 自定义数据类型，允许包装和命名多个相关的值，从而形成一个有意义的组合。就像是对象中的数据属性。



## 5.1 结构体的定义和实例化

1. 结构体包含多个相关的值，每一部分可以是不同类型。
2. 结构体需要命名各部分数据以便能清楚的表明其值的意义。有这些名字，不需要依赖顺序来指定或访问实例中的值。
3. 定义结构体：
	1. 需要使用 struct 关键字并为整个结构体提供一个名字。
	2. 接着，大括号中定义每一部分数据的名字和类型，即字段。

```rust
struct User {
    active: bool,
    username: String,
    email: String,
    sign_in_count: u64,
}
```



4. 使用结构体时，通过为每个字段指定具体值来创建结构体的实例。
5. 创建一个实例需要以结构体的名字开头，接着在大括号用 `key: value` 键 - 值对的形式提供字段，其中 key 是字段的名字，value 是需要存储在字段中的数据值。
6. 实例中字段的顺序不需要和它们在结构体中声明的顺序一致。即结构体的定义就像一个类型的通用模板，而实例则会在这个模板中放入特定数据来创建这个类型的值。

```rust
fn main() {
    let user1 = User {
        active: true,
        username: String::from("someusername123"),
        email: String::from("someone@example.com"),
        sign_in_count: 1,
    };
}
```



7. 可以使用点号从结构体中获取某个特定的值，如果结构体实例是可变的（注意整个实例必须是可变的，rust不允许只将某个字段标记为可变），可以使用点号并为相应的字段赋值：

```rust
fn main() {
    let mut user1 = User {
        active: true,
        username: String::from("someusername123"),
        email: String::from("someone@example.com"),
        sign_in_count: 1,
    };
    // 改变user1中email字段的值
    user1.email = String::from("anotheremaol@example.com");
}
```



8. 可以同其他任何表达式一样，我们可以在函数体的最后一个表达式中构造一个结构体的新实例，来隐式返回这个实例。

```rust
fn build_user(email: String, username: String) -> User {
    User {
        active: true,
        username: username,
        email: email,
        sign_in_count: 1,
    }
}
```



### 使用字段初始化简写语法

1. 参数名与字段名都完全相同时，可以使用字段初始化简写语法：

```rust
fn build_user(email: String, username: String) -> User {
    User {
        active: true,
        username,
        email, // 因为 email 字段与 email 参数有着相同的名称，则只需编写 email 而不是 email: email
        sign_in_count: 1,
    }
}
```



### 使用结构体更新语法从其他实例创建实例

1. 使用旧实例的大部分值但改变其部分值来创建一个新的结构体实例时，可以通过结构体更新语法实现：
2. 结构更新语法就像带有 `=` 的赋值，故而对于带有堆数据的成员变量，使用的是移动赋值。

```rust
fn main() {
    // 不使用结构体更新语法
    let user2 = User {
		active: user1.active,
        username: user1.username,
        email: String::from("another@example.com"),
        sign_in_count: user1.sign_in_count,
    };
    // 使用结构体更新语法
    let user3 = User {
		email: String::from("another.example.com");
        ..user1 // ..语法指定了剩余未显示设置值的字段应有与给定实例对应字段相同的值, 必须放在最后
    };
}
```



### 使用没有命名字段的元组结构体来创建不同的类型

1. 也可以定义与元组类似的结构体，称为元组结构体。
2. 元组结构体具有结构体名称提供的含义，但没有具体的字段名。
3. 如果想给整个元组取一个名字，并使元组成为与其他元组不同类型时，元组结构体是很有用的。
4. 定义元组结构体，以 struct 关键字和结构体名开头，并后跟元组中的类型：
5. 定义的每个结构体都有自己的类型，即使字段相同，也是不同类型。
6. 可以对元组结构体进行解构，也可以使用 `.` 运算符加索引访问单独的值。

```rust
struct Color(i32, i32, i32);
struct Point(i32, i32, i32);

fn main() {
    let black = Color(0, 0, 0);
    let origin = Point(0, 0, 0); // 此时origin和black是不同类型
}
```



### 没有任何字段的类单元结构体

1. 类单元结构体：没有任何字段的结构体。类似于单元元组（unit） 类型。
2. 由于在某个类型上实现 trait 但不需要在类型中存储数据的时候发挥作用。
3. 为类单元结构体类型实现某种行为，使得每个类单元结构体的实例始终等于其他类型的实例。

```rust
struct AlwaysEqual; // 不需要花括号或者圆括号

fn main() {
    let subject = AlwaysEqual;
}
```



### 结构体数据的所有权

1. 如果要使结构体存储被其他对象拥有的数据的引用（slice），得加上生命周期。（第十章）
2. 生命周期确保结构体引用的数据的有效性跟结构体本书保持一致。



## 5.2 结构体示例程序

计算长方形面积：

```rust
fn main() {
    // 计算长方形面积
    let width1 = 30;
    let height1 = 50;
    println!("The area of the rectangle is {} square pixels.", area(width1, height1));
}

fn area(width: u32, height: u32) -> u32 {
    width * height
}
```



### 使用元组重构

```rust
fn main() {
    // 使用元组
    let rect1 = (30, 50);
    println!("The area of the rectangle2 is {} square pixels.", area2(rect1));
}

fn area2(dimensions: (u32, u32)) -> u32 {
    dimensions.0 * dimensions.1
}
```



### 使用结构体重构：赋予更多意义

```rust
struct Rectangle {
    width: u32,
    heighth: u32,
}

// 借用结构体而不是获取它的所有权，这样 main 函数就可以保持 rect1 的所有权并继续使用它
fn main() {
    // 使用结构体重构
    let rect2 = Rectangle {
        heighth: 50,
        width: 30,
    };
    println!("The area of the rectangle3 is {} square pixels.", area3(&rect2));
}

fn area3(rectangle: &Rectangle) -> u32 {
    rectangle.heighth * rectangle.width
}
```



### 通过派生trait增加实用功能

1. println! 宏能处理很多，`{}` 默认使用 `Display` 的格式，基本类型都实现了 `Display` 。
2. 对于结构体，`println!` 应该用来输出的格式是不明确的。
3. 在结构体定义之前加上外部属性 `#[derive(Debug)]` ，以便打印

```rust
#[derive(Debug)] // 增加属性来派生 Debug trait
struct Rectangle {
    width: u32,
    heighth: u32,
}

fn main() {
    let rect2 = Rectangle {
        width: 30,
        heigth: 50,
    };
    println!("rect2 = {rect2:?}"); // rect2 = Rectangle { width: 30, heighth: 50 }
    println!("rect2 = {rect2:#?}");
    /*
    rect2 = Rectangle {
        width: 30,
        heighth: 50,
    }
    */
}
```



4. 另一种使用 `Debug` 格式打印数值的方法是使用 `dbg!` 宏：宏接收一个表达式的所有权（与 `println!` 相反，`println!` 接收的是引用）
5. 打印出代码中调用 dbg! 宏时所在的文件和行号，以及该表达式的结果值，并返回该值的所有权。
6. `dbg!` 宏会打印到标准错误流。

```rust
fn main() {
    let scale = 2;
    let rect3 = Rectangle {
        width: dbg!(30 * scale), // 可以把 dbg! 放在表达式 30 * scale 周围，因为 dbg! 返回表达式的值的所有权，所以 width 字段将获得相同的值，就像在那里没有 dbg! 调用一样
        heighth: 50,
    };
    dbg!(&rect3); // 不希望 dbg! 拥有 rect1 的所有权，所以我们在下一次调用 dbg! 时传递一个引用
}

/*
[src/main.rs:4:16] 30 * scale = 60
[src/main.rs:7:5] &rect3 = Rectangle {
    width: 60,
    heighth: 50,
}
*/
```



## 5.3 方法语法

1. 方法与函数类似：使用 fn 关键字和名称声明，可以拥有参数和返回值，同时包含在某处调用该方法时会执行的代码。
2. 方法与函数又是不同的，因为它们可以在结构体的上下文被定义（或者是枚举或trait对象的上下文），并且第一个参数重视 `self`，代表调用该方法的结构体实例。



### 定义方法

1. 为了使函数定义于结构体上下文，使用 `impl` 关键字构建一个 `impl` 块，这个 `impl` 块中的所有内容都将与结构体类型相关联。
2. 函数的定义放在 `impl` 块中，且函数签名中，第一个参数需要改成  `Self` 类型 的`self` 参数，实际上是结构体类型。rust可以只用self这个名字进行简化。
3. 这个方法可以选择是否获得 self 的所有权，或者是可变&不可变借用。一般很少使用 `self` 作为参数来获得结构体所有权，通常是用在通过方法将结构体转化为别的实例的时候，防止调用者在转化后继续使用原始实例。
4. 方法的名称可以和方法中已有的字段一致。
5. 调用时使用点运算符进行调用。（入参时忽略 `self` 参数）
6. rust不使用 `->` 运算符来调用方法，而是有一个自动引用和解引用，方法调用是rust中少数拥有这种行为的地方。

```rust
#[derive(Debug)] // 增加属性来派生 Debug trait
struct Rectangle {
    width: u32,
    heighth: u32,
}

impl Rectangle {
    // 使用&self来替代rectangle: &Rectangle
    // &self实际上是self: &Self的缩写。
    // 第一个参数必须有一个名为self的Self类型的参数。
    // 可以使用self这个名字来简化，无需显示指定类型。
    fn area(&self) -> u32 {
        self.width * self * height
    }
    
    // 方法的名称可以和方法已有的字段一致
    fn width(&self) -> bool {
        self.width > 0
    }
}

fn main() {
    let scale = 2;
    let rect = Rectangle {
        width: 30,
        heighth: 50,
    };
	println("The area of the rectangle is {} square pixels.", rect.area());   
}
```



### 带有更多参数的方法

1. 在方法签名中，可以在self后增加多个参数。

```rust
impl Rectangle {
    // 这里的签名可以改为
    // fn can_hold(&self, other: &Self) -> bool
    fn can_hold(&self, other: &Rectangle) -> bool {
        self.width > other.width && self.heighth > other.heighth
    }
}
```



### 关联函数

1. 所有在 impl 块中定义的函数被称为关联函数。与impl后面命名的类型相关。
2. 可以定义不以self为第一个参数的关联函数（因此不是方法），因为不作用于一个结构体类型。例如 `String::from` 函数。
3. 不是方法的关联函数经常被用作返回一个结构体新实例的构造函数。这些函数通常名称为 new，但 nwe 并不是一个关键字。
4. 使用结构体名和 `::` 语法调用这个关联函数。这个函数位于结构体的命名空间中，`::` 语法用于关联函数和模块创建的命名空间。

```rust
impl Rectangle {
    fn square(size: u32) -> Self {
        Self {
            width: size,
            heighth: size,
        }
    }
}

fn main() {
    let sq = Rectangle::square(3);
}
```



### 多个impl块

1. 每个结构体都允许拥有多个 `impl` 块。
2. 泛型和trait时会看到实用的多 `impl` 块的用例。

```rust
impl Rectangle {
    fn area(&self) -> u32 {
        self.width * self * height
    }
}

impl Rectangle {
    fn can_hold(&self, other: &Rectangle) -> bool {
        self.width > other.width && self.heighth > other.heighth
    }
}
```



# 6 枚举和模式匹配

1. 枚举允许通过列举可能的成员来定义一个类型。



## 6.1 枚举的定义

1. 结构体是将字段和数据聚合在一起的方法，而枚举是声明某个值是一个集合中的一员。
2. 枚举出所有可能的值。
3. 例如枚举ip地址类别：

```rust
enum IpAddrKind {
    V4,
    V6,
}
```



### 枚举值

1. 枚举的成员位于其标识符的命名空间中。

```rust
let four = IpAddrKind::V4;
```



2. 将数据存入每一个枚举成员中，直接将数据附加到枚举的每个成员上，此时，定义的枚举成员的名字变成一个构造枚举实例的函数。

```rust
enum IpAddr {
    V4(String),
    V6(String),
}

// IpAddr::V4()是一个获取String参数并返回构建枚举的实例的函数
let four = IpAddr::V4(String::from("127.0.0.1"));
```



3. 每个成员可以处理不同类型和数量的数据：

```rust
enum IpAddr {
    V4(u8, u8, u8, u8),
    V6(String),
}
```



4. 可以使用 `impl` 来给枚举定义方法。

```rust
enum Message {
    Quit,
    Move { x: i32, y: i32 }, // 结构体
    Write(String),
    ChangeColor(i32, i32, i32),
}

impl  Message {
    fn call(&self) {

    }
}

fn main() {
    let m = Message::Write(String::from("hello"));
    m.call();
}
```



### Option枚举和其相对于空值的优势

1. Option是标准库定义的一个枚举。

2. 应用场景：一个值要么有值，要么没值。

	例如：请求一个非空列表的第一项，会得到一个值，如果请求一个空的列表，就什么也得不到。

	从类型系统的角度来表达这个概念就意味着编译器需要检查是否处理了所有应该处理的情况，从而避免常见的bug。

3. rust没有空值（例如c/c++的空指针）的功能。而是拥有一个可以编码存在或不存在概念的枚举。即 `Option<T>`。

```rust
enum Option<T> {
    None,
    Some(T),
}
```



4. `Option<T>` 类型被包含在 `prelude` 之中，其成员也是如此，可以不需要 `Option::` 直接使用 `Some` 和 `Note`。

```rust
let some_number = Some(5);
let some_char = Some('e');
let absent_number: Option<i32> = None; // 通过None编译器无法推断类型，故需要显示指出是 Option<i32> 类型
```



5. 当有一个 `Some` 值时，就知道存在一个值，且保持在 `Some` 中。
6. `Option<T>` 和 `T` 是不同的类型，编译器不允许像一个有效的值那样使用 `Option<T>` 。

```rust
fn main() {
    let x: i8 = 5;
    let y: Option<i8> = Some(5);
    
    let sum = x + y; // err, 不同类型，无法相加
}
```



7. 使用 `Option<T>` 进行运算时必须将其转换为 `T`。
8. 当拥有一个可能为空的值，必须要显示的将其放入对应的类型 `Option<T>` 中。接着，当使用这个值时，必须明确的处理值为空的情况。故而，只要一个值不是 `Option<T>` 类型，就可以安全的认定值不为空。通过这种设计，限制空值的泛用。
9. 总的来说，为了使用 `Option<T>` 值，需要编写处理每个成员的代码。你想要一些代码只当拥有 `Some(T)` 值时运行，允许这些代码使用其中的 `T`。也希望一些代码只在值为 `None` 时运行，这些代码并没有一个可用的 `T` 值。`match` 表达式就是这么一个处理枚举的控制流结构：它会根据枚举的成员运行不同的代码，这些代码可以使用匹配到的值中的数据。



## 6.2 match控制流结构

1. `match` 是一个运算符，允许将一个值和一系列的模式相比较，并根据相匹配的模式执行相应代码。
2. 模式可由字面值、变量、通配符和许多其他内容构成。
3. `match` 的力量来源于模式的表现力以及编译器检查，确保所有可能的情况都得到处理。
4. `match` 后面跟随一个表达式，而且与 `if` 语句的表达式必须返回布尔类型不同的是，`match` 的表达式可以是任何类型。
5. `match` 分支有两部分：一个模式和一个代码块；并使用 `=>` 将模式和代码块分开，每个分支之间用逗号分隔。
6. `match` 表达式执行时，它将结果值按顺序与 `match` 的每一个模式相比较，如果模式匹配这个值，这个模式相关联的代码将被执行；如果模式并不匹配这个值，将继续执行下一个分支。
7. 每一个分支相关联的代码是一个表达式，而表达式的结果的值将作为整个 `match` 表达式的返回值。
8. 如果分支代码较短的话通常不使用大括号；如果想要在分支中运行多行代码，可以使用大括号，此时，分支后的逗号是可选的。

```rust
// 获取一个未知的硬币，并以一个类似于验钞机的方式，确定是何种硬币并返回其美分值

enum Coin {
    Penny,
    Nickel,
    Dime,
    Quarter,
}

fn value_in_cents(coin : Coin) -> u8 {
    // match exep
    match coin {
        Coin::Penny => 1,
        Coin::Nickel => 5,
        Coin::Dime => 10,
        Coin::Quarter => 25,
    }
}
```



### 绑定值的模式

1. 匹配分支的另一个有用的功能是可以绑定匹配的模式的部分值，也就是如何从枚举成员中提取值。

```rust
#[derive(Debug)] // 便于打印
enum UsState {
    Alabama,
    Alaska,
}

enum Coin {
    Penny,
    Nickel,
    Dime,
    Quarter(UsState), // 使用枚举成员存放数据
}

fn value_in_cents(coin : Coin) -> u8 {
    match coin {
        Coin::Penny => 1,
        Coin::Nickel => 5,
        Coin::Dime => 10,
        Coin::Quarter(state) => { // 使用state变量提取枚举成员存放的数据
            println!("State quarter from {state:?}!");
            25
        }
    }
}
```



### 匹配 Option< T >

```rust
// 编写一个函数，它获取一个 Option<i32> ，如果其中含有一个值，将其加一。如果其中没有值，函数应该返回 None 值，而不尝试执行任何操作
fn plus_one(x: Option<i32>) -> Option<i32> {
    match x {
        None => x,
        Some(i) => Some(i + 1),
    }
}
```



### 匹配Some(T)

1. `match` 一个枚举，绑定其中的值到一个变量，接着根据其值执行代码。

```rust
let five = Some(5);
let six = plus_one(five);

/*
1. 当调用 plus_one(five) 时，plus_one 函数体中的 x 将会是值 Some(5)。接着将其与每个分支比较。
2. 值 Some(5) 并不匹配模式 None，所以继续进行下一个分支。
3. Some(5) 与 Some(i) 匹配吗？当然匹配！它们是相同的成员。i 绑定了 Some 中包含的值，所以 i 的值是 5。接着匹配分支的代码被执行，所以我们将 i 的值加一并返回一个含有值 6 的新 Some。
*/
```



### 匹配是穷尽的

1. `match` 的分支必须覆盖所有的可能性。必须穷举到最后的可能性来使代码有效。



### 通配模式和 _ 占位符

1. 希望对一些特定值采取特殊操作，而对其他值采取默认操作。
2. 必须将通配分支放在最后，因为模式匹配是按顺序的。

```rust
let dice_roll = 9;
match dice_roll {
    3 => ,
    7 => ,
    other => func(other), // 通配分支，覆盖未被列出的所有其他可能的值，模式是一个名为other的变量。
}
```



3. rust还提供一个模式，当不想使用通配模式获取的值时，使用 `_`，这是一个特殊的模式，可以匹配任意值而不绑定到该值。

```rust
let dice_roll = 9;
match dice_roll {
    3 => ,
    7 => ,
    _ => func(),
}
```



4. 即可以使用一个标识符来绑定其余的值，也可以使用 `_` 来忽略其余所有可能的值。



## 6.3 if let 简洁控制流

> 可以认为是 `match` 的语法糖

1. `if let` 语法以一种不那么冗长的方式结合 `if` 和 `let`，来处理只匹配一个模式的值而忽略其他模式的情况。
2. `if let` 语法获取通过等号分隔的一个模式和一个表达式，它的工作方式与 `match` 相同；这里的表达式对应 `match`，而模式则对应第一个分支。
3. 模式不匹配时，`if let` 块中的代码不会执行。
4. 缺点：失去 `match` 强制要求的穷尽性检查。
5. 可以包含 `else` 分支，相当于 `match` 表达式中的 `_`。

```rust
// 如果值是 Some，我们希望打印出 Some 成员中的值，这个值被绑定到模式中的 max 变量里。
// 对于 None 值我们不希望做任何操作。为了满足 match 表达式（穷尽性）的要求，必须在处理完这唯一的成员后加上 _ => ()
let config_max = Some(3u8);
match config_max {
    Some(max) => println!("The maximum is configured to be {max}"),
    _ => (),
}

// 使用 if let
// Some(max): 模式
// config_max：表达式
if let Some(max) = config_max {
    println!("The maximum is configured to be {max}");
}
```



# 7 使用包、Crate和模块管理不断增长的项目

1. 一个包可以包含多个二进制 crate 项和一个可选的 crate 库。
2. 伴随包的增长，可以将包中的部分代码提取出来，做成独立的 ceate，这些 crate 则作为外部依赖项。
3. 对于一个由一系列相互关联的包组成的超大型项目，cargo 提供了工作空间这一功能。
4. 模块系统：
	- 包：cargo 的一个功能，允许构建、测试和分享 crate。
	- Crates：一个模块的树形结构，形成了库或二进制项目。
	- 模块和 use：允许控制作用域和路径的私有性。
	- 路径：一个命名例如结构体、函数或模块等项的方式。



## 7.1 包和 Crate

1. crate 是 rust 在编译时最小的代码单位。如果使用 `rustc` 而不是 `cargo` 来编译一个文件，编译器还是会将那个文件认作一个 crate。
2. crate 可以包含模块，模块可以定义在其他文件，然后和 crate  一起编译。
3. crate 有两种形式：二进制项和库。
	- 二进制项可以被编译为可执行程序，必须有一个 `main` 函数。
	- 库并没有 `main` 函数，，也不会编译为可执行程序。提供诸如函数之类的东西，其他项目也能使用这些东西。
4. crate root 是一个源文件，rust 编译器以它为起始点，构建 crate 的根模块。
5. 包是提供一系列功能的一个或者多个 crate。一个包会包含一个 Cargo.toml 文件，阐述如何去构建这些 crate。Cargo 就是一个包含构建代码的二进制项的包。cargo 也包含这些二进制项所依赖的库。其他项目也可以用 cargo 库来实现与 cargo 命令行程序一样的逻辑。
6. 包中可以包含至多一个库 crate。包中可以包含任意多个二进制 crate，但是必须至少包含一个 crate。
7. Cargo 遵循的一个约定：*src/main.rs* 就是一个与包同名的二进制 crate 的 crate 根。同样的，Cargo 知道如果包目录中包含 *src/lib.rs*，则包带有与其同名的库 crate，且 *src/lib.rs* 是 crate 根。crate 根文件将由 Cargo 传递给 `rustc` 来实际构建库或者二进制项目。
8. 如果一个包同时含有 *src/main.rs* 和 *src/lib.rs*，则它有两个 crate：一个二进制的和一个库的，且名字都与包相同。通过将文件放在 *src/bin* 目录下，一个包可以拥有多个二进制 crate：每个 *src/bin* 下的文件都会被编译成一个独立的二进制 crate。



## 7.2 定义模块来控制作用域与私有性

1. use：将路径引入作用域的关键字。
2. pub：将项变为公有的关键字。
3. as：
4. 外部包
5. glob运算符



### 模块小抄

- **从ctate根节点开始**：当编译一个crate，编译器首先在crate根文件（通常，对于一个库crate而言是 src/lib.rs，对于一个二进制而言是 src/main.rs）中寻找需要被编译的源码。
- **声明模块**：在 crate根文件中，可以声明一个新模块；比如，用 `mod garden;` 声明了一个叫做 `graden` 的模块。编译器会在下列路径中寻找模块代码：
  - 内联：在大括号中，当 `mod garden` 后方不是一个分号而是一个大括号。
  - 在文件 src/garden.rs
  - 在文件 src/garden/mod.rs
- **声明子模式**：在除了 crate 根节点以外的其他文件中，可以定义子模块。比如，可能在 src/garden.rs 中定义了 `mod vegetables;`，编译器会在以父模块命名的目录中寻找子模块代码：
  - 内联：在大括号中，当 `mod vegetables` 后方不是一个分号而是一个大括号。
  - 在文件 src/garden/vegetables.rs
  - 在文件 src/garden/vegetables/mod.rs
- **模块中的代码路径**：一旦一个模式是crate的一部分，可以在隐私规则允许的前提下，从同一个crate内的任意地方，通过代码路径引用该模块的代码。举例而言，一个 garden vegetable模块下的 `Asparagus` 类型可以在 `crate::garden::vegetable::Asparagus` 被找到。
- **私有 vs 公有**：一个模块里的代码默认对其父模块私有。为了使一个模块公有，应当在声明时使用 `pub mod` 代替 `mod`。为了使一个公有模块内部的成员公用，应当在声明前使用 `pub`。
- **use 关键字**：在一个作用域内，use关键字创建了一个成员的快捷方式，用来减少路径的重复。在任何可以引用 `crate::garden::vegetables::Asparagus` 的作用域，可以通过 `use crate::garden::vegetables::Asparagus;` 创建一个快捷方式，然后就可以在作用域中只使用 `Asparagus` 来使用该类型。



**例如**：

```rust
/*
backyard
├── Cargo.lock
├── Cargo.toml
└── src
    ├── garden
    │   └── vegetables.rs
    ├── garden.rs
    └── main.rs
*/

// crate 根文件是 src/main.rs
// src/main.rs
use crate::garden::vegetables::Asparagus;

pub mod garden; // 告诉编译器应该包含在src/garden.rs文件中发现的代码

fn main() {
    let plant = Asparagus {};
    println!("I'm growing {plant:?}!");
}

/////////////////////////////////////////////////////////////

// src/garden.rs
pub mod vegetables; // 意味着在src/garden/vegetables.rs中的代码也应该被包括

// 这些代码是：
#[derive(Debug)]
pub struct Asparagus {}
```



### 在模块中对相关代码进行分组

1. 模块让我们可以将一个 crate 中的代码进行分组，以提高可读性与重用性。
2. 因为一个模块中的代码默认是私有的，所以还可以利用模块控制项的私有性。私有项是不可为外部使用的内在详细实现。
3. 也可以将模块和它其中的项标记为公开，这样，外部代码就可以使用并依赖它们。
4. 可以将函数放置到嵌套的模块中。
5. 定义模块：以 mod 关键字为起始，然后指定模块的名字，并且用花括号包围模块的主体；模块还可以保存一些定义的其他项，比如结构体，枚举、常量、特性、或者函数。
6. 通过使用模块，可以将相关的定义分组到一起，并指出它们为什么相关。
7.  `src/main.rs` / `src/lib.rs` 叫做 crate 根，之所以这样叫它们是因为这两个文件的内容分别在 crate 模块结构的根组成一个名为 crate 的模块，该结构被称为模块树（module tree）。
8. 如果一个模块 A 被包含在模块 B 中，我们将模块 A 称为模块 B 的 *子*（*child*），模块 B 则是模块 A 的 *父*（*parent*）。注意，整个模块树都植根于名为 `crate` 的隐式模块下。



例如：

```rust
// cargo new --lib restaurant

/*
模块树结构
crate
 └── front_of_house
     ├── hosting
     │   ├── add_to_waitlist
     │   └── seat_at_table
     └── serving
         ├── take_order
         ├── serve_order
         └── take_payment
*/

// src/lib.rs
// 前台
mod front_of_hourse {
    mod hosting {
        fn add_to_waitlist() {}
        fn seat_at_table() {}
    }

    mod serving {
        fn take_order() {}
        fn server_order() {}
        fn take_payment() {}
    }
}
```



## 7.3 引用模块项目的路径

1. 使用路径的方式，就像在文件系统使用路径一样，为了调用一个函数，需要知道其路径。

2. 路径有两种形式：

   - 绝对路径：是以 crate 根开头的全路径；对于外部 crate 的代码，是以 crate 名开头的绝对路径，对于当前的 crate 的代码，则以字面值 crate 开头。
   - 相对路径从当前模块开始，以 self、super或定义在当前模块中的标识符开头。

   绝对路径和相对路径都后跟一个或多个由双冒号分隔的标识符；更建议使用绝对路径。

3. 使用 pub 关键字来定义一个公共 API，将子模块的内部部分暴露给上级模块。

4. rust中，默认所有项（函数、方法、结构体、枚举和常量）对父模块都是私有的，如果希望创建一个私有函数或结构体，可以将其放入一个模块中。

5. 父模块中的项不能使用子模块中的私有项，但是子模块中的项可以使用它们父模块中的项；这是因为子模块封装并隐藏了它们的实现详情，但是子模块可以看到它们定义的上下文。

```rust
// src/lib.rs
// 无法通过编译，hosting模块是私有的
mod front_of_hourse {
    mod hosting {
        fn add_to_waitlist() {}
    }
}

pub fn eat_at_restaurant() {
    // err: 父模块中的项不能使用子模块中的私有项
    // 绝对路径
    // add_to_waitlist和eat_at_restaurant被定义在同一crate中，故可以使用crate关键字为起始的绝对路径
    crate::front_of_hourse::hosting::add_to_waitlist();

    // 相对路径
    // front_of_hourse模块和eat_at_restaurant定义在同一层级，故相对路径以front_of_hourse为起始，如下：
    front_of_hourse::hosting::add_to_waitlist();
}
```



### 使用pub关键字暴露路径

1. 模块公有不代表其内容也公有。模块上的pub关键字只允许其父模块引用它，而不允许访问内部代码。
2. 模块是一个容器，只是将模块变为公有能做的其实并不太多，同时需要更深入地选择将一个或多个项变为公有。
3. 私有规则不但应用于模块，还应用于结构体、枚举、函数和方法。
4. 处于同一层级的模块或函数或结构体之间是相互可见的。

```rust
// src/lib.rs
mod front_of_hourse {
    // 使用pub关键字标记hosting模块，示其暴露给父模块
    pub mod hosting {
        fn add_to_waitlist() {}
    }
}

// 
pub fn eat_at_restaurant() {
    // err: hosting模块公有，但是add_to_waitlist函数为私有
    
    // 绝对路径
    // add_to_waitlist和eat_at_restaurant被定义在同一crate中，故可以使用crate关键字为起始的绝对路径
    crate::front_of_hourse::hosting::add_to_waitlist();

    // 相对路径
    // front_of_hourse和eat_at_restaurant定义在同一层级，故相对路径如下：
    front_of_hourse::hosting::add_to_waitlist();
}
```



4. 定义在同一层级的模块或函数、结构体等相互可见。

```rust
// src/lib.rs
mod front_of_hourse {
    // 使用pub关键字标记hosting模块，示其暴露给父模块
    pub mod hosting {
        pub fn add_to_waitlist() {}
    }
}

pub fn eat_at_restaurant() {
    // 定义在同一层级的模块或函数、结构体等相互可见；故eat_at_restaurant可以直接使用front_of_hourse，而无需使用pub修饰front_of_hourse
    
    // 绝对路径
    // add_to_waitlist和eat_at_restaurant被定义在同一crate中，故可以使用crate关键字为起始的绝对路径
    crate::front_of_hourse::hosting::add_to_waitlist();

    // 相对路径
    // front_of_hourse和eat_at_restaurant定义在同一层级，故相对路径如下：
    front_of_hourse::hosting::add_to_waitlist();
}
```



### super开始的相对路径

1. 可以通过在路径的开头使用super，从父模块开始构建相对路径，而不是从当前模块或者crate根开始。这类似以 `..` 语法开始一个文件系统路径。
2. 使用 super 允许引用父模块中的已知项。

```rust
// src/lib.rs

fn deliver_order() {}

mod back_of_house {
    fn fix_incorrect_order() {
        cook_order();
        // fix_incorrect_order 函数在 back_of_house 模块中，所以我们可以使用 super 进入 back_of_house 父模块，也就是本例中的 crate 根
        super::deliver_order();
    }
    fn cook_order() {}
}
```



### 创建公有的结构体和枚举

1. 今天使用pub来设计公有的结构体和枚举。
2. 如果在一个结构体定义的前面使用了pub，这个结构体会变成公有的，但是这个结构体的字段仍然是私有的。可以根据情况决定每个字段是否公有。
3. 结构体遵循常规，内容全部是私有的，除非使用 `pub` 关键字

```rust
mod back_of_house {
    // 定义了一个公有结构体 back_of_house:Breakfast，其中有一个公有字段 toast 和私有字段 seasonal_fruit
    pub struct Breakfast {
        pub toast: String,
        seasonal_fruit: String,
    }
    impl Breakfast {
        pub fn summer(toast: &str) -> Breakfast {
            Breakfast {
                toast: String::from(toast),
                seasonal_fruit: String::from("peaaches"),
            }
        }
    }
}

pub fn eat_at_restaurant() {
    // 在夏天订购一个黑麦土司作为早餐
    let mut meal = back_of_house::Breakfast("Rye");
    // 改变主意更换想要面包的类型
    // 因为 back_of_house::Breakfast 结构体的 toast 字段是公有的，所以我们可以在 eat_at_restaurant 中使用点号来随意的读写 toast 字段
    meal.toast = String::from("Wheat");
    println!("I'd like {} toast please", meal.toast);

    // 如果取消下一行的注释代码不能编译；
    // 不允许查看或修改早餐附带的季节水果
    // 不能在 eat_at_restaurant 中使用 seasonal_fruit 字段，因为 seasonal_fruit 是私有的
    // meal.seasonal_fruit = String::from("blueberries");
}
```



3. 如果将枚举设为公有，则它的所有成员都将变为公有。

```rust
// src/lib.rs

mod back_of_house {
    pub enum Appetizer {
        Soup,
        Salad,
    }
}

pub fn eat_at_restaurant() {
    // 创建了名为 Appetizer 的公有枚举，所以我们可以在 eat_at_restaurant 中使用 Soup 和 Salad 成员
    let order1 = back_of_house::Appetizer::Soup;
    let order2 = back_of_house::Appetizer::Salad;
}
```



## 7.4 使用use关键字将路径引入作用域

1. 可以使用use关键字创建一个短路径，然后就可以在作用域中的任何地方使用这个更短的名字。
2. 在作用域中增加use和路径类似于在文件系统中创建软连接（符号链接，symbolic link）。
3. 通过use引入作用域的路径也会检查私有性，同其他路径一样。
4. 注意，use只能创建use所在的特定作用域内的短路径。

```rust
mod front_of_house {
    pub mod hosting {
        pub fn add_to_waitlist() {}
    }
}

// 通过在crate根增加use crate::front_of_house::hosting，现在hosting在作用域中就是有效的名称
// 引入函数时，不会直接引入到函数名那一层，一般会保留其父模块
use crate::front_of_house::hosting;

pub fn eat_at_restaurant() {
    hosting::add_to_waitlist();
}

mod customer {
    // 这是一个不同于use语句的作用域，err
    pub fn eat_at_restaurant() {
        hosting::add_to_waitlist();
    }
}
```



### 创建惯用的use路径

1. 按照惯例，引入函数时，不会直接引入到函数名那一层，一般会保留其父模块；而引入结构体，枚举和其他项时，习惯是指定它们的完整路径。

```rust
// 引入结构体，枚举和其他项时，习惯是指定它们的完整路径
use std::collections::HashMap;

fn main() {
    let mut map = HashMap::new();
    map.insert(1, 2);
}
```



2. rust不允许引入两个具有相同名称的项带入作用域。

```rust
// 如何将两个具有相同名称但不同父模块的Result类型引入作用域
// 使用父模块可以区分两个Result类型
use std::fmt;
use std::io;

fn function1() -> fmt::Result {
    
}
fn function2() -> io::Result {
    
}
```



### 使用as关键字提供新的名称

1. 使用use将两个同名类型引入同一作用域还有另一种解决方法：

   在这个类型的路径后面，使用as指定一个新的本地名称或者别名。

```rust
use std::fmt::Result;
use std::io::Result as IoResult;

fn function1() -> fmt::Result {
    
}
fn function2() -> IoResult {
    
}
```



### 使用pub use重导出名称

1. 使用use关键字，将某个名称导入当前作用域后，这个名称在此作用域中就可以使用了，但它对此作用域之外还是私有的。
2. 如果想让其他人调用该代码时，也能正常使用这个名称，就好像它本来就在当前作用域一样，可以将pub和use结合起来使用；即重导出：不仅将一个名称导入了当前作用域，还允许别人把它导入自己的作用域。
3. 当代码的内部结构与调用代码的程序员所想象的结构不同时，重导出会很有用。
4. 使用pub use，我们可以使用一种结构编写代码，却将不同的结构形式暴露出来，使得编写的库井井有条。

```rust
// src/lib.rs
mod front_of_house {
    pub mod hosting {
        pub fn add_to_waitlist() {}
    }
}

// 添加pub之前，外部代码需要使用路径 restaurant::front_of_house::hosting::add_to_waitlist() 来调用add_to_waitlist函数
// 添加pub之后，只需要 restaurant::hosting::add_to_waitlist() 来调用add_to_waitlist函数
pub use crate::front_of_house::hosting;

pub fn eat_at_restaurant() {
    hosting::add_to_waitlist();
}
```



### 使用外部包

1. 注意 `std` 标准库对于你的包来说也是外部 crate。因为标准库随 Rust 语言一同分发，无需修改 *Cargo.toml* 来引入 `std`，不过需要通过 `use` 将标准库中定义的项引入项目包的作用域中来引用它们。

```rust
use std::collections::HashMap; // 这是一个以标准库 crate 名 std 开头的绝对路径。
```



### 嵌套路径来消除大量的use行

1. 可以使用嵌套路径将相同的项在一行中引入作用域。这么做需要指定路径的相同部分，接着是两个冒号，接着是大括号中的各自不同的路径部分

```rust
// before
use std::cmp::Ordering;
use std::io;

// 使用嵌套路径：指定嵌套的路径在一行中将多个带有相同前缀的项引入作用域
use std::{cmd::Ordering, io};
```



2. 可以在路径的任何层级使用嵌套路径，这在组合两个共享子路径的 use 语句时非常有用.
3. 为了在一行 `use` 语句中引入这两个路径，可以在嵌套路径中使用 `self`

```rust
// before
use std::io;
use std::io::Write;

// 通过两行 use 语句引入两个路径，其中一个是另一个的子路径
use std::io::{self, Write};
```



### 通过glob运算符将所有的公有定义引入作用域

1. 如果希望将一个路径下 **所有** 公有项引入作用域，可以指定路径后跟 `*`，glob 运算符：
2. glob 运算符经常用于测试模块 `tests` 中，这时会将所有内容引入作用域

```rust
use std::collections::*;
```



## 7.5 将模块拆分成多个文件

1. 可以将模块提取到各自的文件中，而不是将所有模块都定义到 crate 根文件中。适用于库文件和二进制文件。
2. 只需要在模块树的某处使用一次mod声明就可以加载这个文件。
3. 一旦编译器知道了这个文件是项目的一部分（并且通过mod语句的位置知道了代码在模块树的位置），项目中的其他文件应该使用其声明所在的路径来引用那个文件的代码。换句话说，`mod` **不是** 你可能会在其他编程语言中看到的 "include" 操作。

```rust
// src/lib.rs
// 声明mod front_of_house;
mod front_of_house; // 编译器在crate根中找到一个名叫front_of_hosting的模块声明，就知道去搜索front_of_hosting.rs这个文件

pub use crate::front_of_hourse::hosting;

pub fn eat_at_restaurant() {
    hosting::add_to_waitlist();
}

////////////////////////////////////////

// src/front_of_house.rs
pub mod hosting {
    pub fn add_to_waitlist() {}
}
```



4. 编译器所遵循的哪些文件对应哪些模块的代码的规则，意味着目录和文件更接近于模块树。
5. 将各个模块的代码移动到独立文件了，同时模块树依旧相同。这个技巧让你可以在模块代码增长时，将它们移动到新文件中。
6. use 也不会对哪些文件会被编译为 crate 的一部分有任何影响。`mod` 关键字声明了模块，而 Rust 会在与模块同名的文件中查找模块的代码。
7. Rust 提供了将包分成多个 crate，将 crate 分成模块，以及通过指定绝对或相对路径从一个模块引用另一个模块中定义的项的方式。
8. 可以通过使用 `use` 语句将路径引入作用域，这样在多次使用时可以使用更短的路径。模块定义的代码默认是私有的，不过可以选择增加 `pub` 关键字使其定义变为公有。

```rust
//// 将hosting模块提取到自己的文件中：

// src/lib.rs
mod front_of_house; // 编译器在crate根中找到一个名叫front_of_hosting的模块声明，就知道去搜索front_of_hosting.rs这个文件

// src/lib.rs 中的 pub use crate::front_of_house::hosting 语句也并未发生改变。use 也不会对哪些文件会被编译为 crate 的一部分有任何影响。
pub use crate::front_of_house::hosting;

// 将各个模块的代码移动到独立文件了，同时模块树依旧相同
// eat_at_restaurant 中的函数调用也无需修改继续保持有效，即便其定义存在于不同的文件中。
pub fn eat_at_restaurant() {
    hosting::add_to_waitlist();
}

/////////////////////////////////////////

// src/front_of_house.rs
pub mod hosting; // 声明了hosting模块，由于hosting是front_of_house的子模块，而不是根模块，故 hosting.rs 文件应位于 src/front_of_house/ 目录下, 即和父模块同名的目录下

/////////////////////////////////////////

// src/front_of_house/hosting.rs
// 如果将 hosting.rs 放在 src 目录，编译器会认为 hosting 模块中的 hosting.rs 的代码声明于 crate 根，而不是声明为 front_of_house 的子模块

pub fn add_to_waitlist() {}
```



### 另一种文件路径

> 老风格

1. 对于声明于 crate 根的 `front_of_house` 模块，编译器会在如下位置查找模块代码：

   - *src/front_of_house.rs* 

   - *src/front_of_house/mod.rs*（老风格，不过仍然支持）

2. 对于 `front_of_house` 的子模块 `hosting`，编译器会在如下位置查找模块代码：

   - *src/front_of_house/hosting.rs* 

   - *src/front_of_house/hosting/mod.rs*（老风格，不过仍然支持）

3. 如果你对同一模块同时使用这两种路径风格，会得到一个编译错误。在同一项目中的不同模块混用不同的路径风格是允许的，不过这会使他人感到疑惑。

4. 使用 *mod.rs* 这一文件名的风格的主要缺点是会导致项目中出现很多 *mod.rs* 文件，当你在编辑器中同时打开它们时会感到疑惑。



# 8 常见集合

1. Rust 标准库中包含一系列被称为 **集合**（*collections*）的非常有用的数据结构。大部分其他数据类型都代表一个特定的值，不过集合可以包含多个值。
2. 不同于内建的数组和元组类型，这些集合指向的数据是储存在堆上的，这意味着数据的数量不必在编译时就已知，并且还可以随着程序的运行增长或缩小。
3. 三个在 Rust 程序中被广泛使用的集合：
   - *vector* 允许我们一个挨着一个地储存一系列数量可变的值
   - **字符串**（*string*）是字符的集合。我们之前见过 `String` 类型，不过在本章我们将深入了解。
   - **哈希 map**（*hash map*）允许我们将值与一个特定的键（key）相关联。这是一个叫做 *map* 的更通用的数据结构的特定实现。



## 8.1 使用Vector存储列表

1. 标准库提供的类型，可以直接使用。
2. `Vec` 是分配在堆上的、可增长的数组。
3. `<T>` 表示泛型，使用时确定实际的类型。例如：`Vec<i32>`。
1. vector 允许在一个单独的数据结构中储存多于一个的值，它在内存中彼此相邻地排列所有的值。vector 只能储存相同类型的值。



### 新建vector

1. vector 是用泛型实现的。
2.  `Vec<T>` 是一个由标准库提供的类型，它可以存放任何类型，而当 `Vec` 存放某个特定类型时，那个类型位于尖括号中，例如 `Vec<i32>`。 
3. Rust 提供了 `vec!` 宏，这个宏会根据我们提供的值来创建一个新的 vector，来创建有一定元素的向量。

```rust
let v: Vec<i32> = Vec::new(); // 这里我们增加了一个类型注解。因为没有向这个 vector 中插入任何值，Rust 并不知道我们想要储存什么类型的元素。

let v = vec![1, 2, 3]; // Vec<i32>
```



### 更新vector

1. 对于新建一个 vector 并向其增加元素，可以使用 `push` 方法:

```rust
let mut v = Vec::new(); // 必须使用mut使其可变

v.push(5);	// 由于push的值都是i32，故而编译器可以自己推断类型
v.push(6);
v.push(7);
v.push(8);
```



### 读取vector元素

1. 使用索引或者get方法：
2. 使用 `&` 和 `[]` 会得到一个索引位置元素的引用.
3. 当使用索引作为参数调用 `get` 方法时，会得到一个可以用于 `match` 的 `Option<&T>`。
4. 提供了两种引用元素的方法的原因是当尝试使用现有元素范围之外的索引值时可以选择让程序如何运行。
   - 对于使用 `[]` 运算符传入的下标，如果下标非法的情况下，会造成 panic，使得程序崩溃。
   - 而使用 get 非法访问非法下标时，得到的是一个 `None`，而不会使得程序 panic 崩溃。

```rust
fn main() {
    let vec = vec![1, 2, 3, 4, 5];
    let third: &i32 = &vec[2];
    println!("The third elem is {third}");

    let third: Option<&i32> = vec.get(2);
    match third {
        Some(third) => println!("The third elem is {third}"),
        None => println!("There is no third elem"),
    }
}
```



5. 一旦程序获取了一个有效的引用，借用检查器将会执行所有权和借用规则（第四章讲到）来确保 vector 内容的这个引用和任何其他引用保持有效。（即不能在相同作用域中同时存在可变和不可变引用的规则）

```rust
fn main() {
  let mut v = vec![1, 2, 3, 4, 5];
  let first = &v[0]; // 不可变引用

  v.push(6); // 可变引用
  println!("first = {}", first); // 不可变引用仍在使用，err，在相同作用域中同时存在可变和不可变引用
    // 为什么第一个元素的引用会关心 vector 结尾的变化？
    // 不能这么做的原因是由于 vector 的工作方式：在 vector 的结尾增加新元素时，在没有足够空间将所有元素依次相邻存放的情况下，可能会要求分配新内存并将老的元素拷贝到新的空间中。这时，第一个元素的引用就指向了被释放的内存。借用规则阻止程序陷入这种状况。
}
```



### 遍历vecor中的元素

1. 因为借用检查器的规则，无论可变还是不可变地遍历一个 vector 都是安全的。
2. 在遍历循环体内插入或删除项，都是违反了所有权规则。

```rust
fn main() {
    let mut v = vec![1, 2, 3, 4, 5];
    
    // 遍历获取不可变应用
    for i in &mut v {
        *i += 50; // 为了修改可变引用所指向的值，在使用 += 运算符之前必须使用解引用运算符（*）获取 i 中的值
    }
    
    // 遍历获取可变引用
    for i in &v {
        println!("{i} ");
    }
}
```



### 使用枚举来存储多种类型

1. vector 只能储存相同类型的值。这是很不方便的；绝对会有需要储存一系列不同类型的值的用例。
2. 枚举的成员都被定义为相同的枚举类型，所以当需要在 vector 中储存不同类型值时，我们可以定义并使用一个枚举，其成员会存放这些不同类型的值，同时所有这些枚举成员都会被当作相同类型：那个枚举的类型！

```rust
fn main() {
    // 假如我们想要从电子表格的一行中获取值，
    // 而这一行的有些列包含数字，有些包含浮点值，还有些是字符串。
    enum SpreadsheetCell {
        Int(i32),
        Float(f64),
        Text(String),
    }

    let row = vec![
        SpreadsheetCell::Int(3),
        SpreadsheetCell::Float(3.0),
        SpreadsheetCell::Text(String::from("value")),
    ];
}
```



3. Rust 在编译时必须确切知道 vector 中的类型，这样它才能确定在堆上需要为每个元素分配多少内存。我们还必须明确这个 vector 中允许的类型。
4. 如果 Rust 允许 vector 存储任意类型，那么可能会因为一个或多个类型在对 vector 元素执行操作时导致（类型相关）错误。
5. 使用枚举加上 `match` 表达式意味着 Rust 会在编译时确保每种可能的情况都得到处理，



### 丢弃vector时也会丢弃其所有元素

1. 类似于任何其他的 `struct`，vector 在其离开作用域时会被释放。
2. 当 vector 被丢弃时，所有其内容也会被丢弃，这意味着这里它包含的整数将被清理。借用检查器确保了任何 vector 中内容的引用仅在 vector 本身有效时才可用。



### 其他api

1. pop方法：移除并返回vector的最后一个元素



## 8.2 使用字符串存储UTF-8编码的文本

1. 字符串就是作为字节的集合外加一些方法实现的，当这些字节被解释为文本时，这些方法提供了实用的功能。



### 什么是字符串？

1. Rust 的核心语言中只有一种字符串类型：字符串 slice `str`，它通常以被借用的形式出现，`&str`。
2. **字符串 slices**：它们是一些对储存在别处的 UTF-8 编码字符串数据的引用。举例来说，由于字符串字面值被储存在程序的二进制输出中，因此字符串字面值也是字符串 slices。
3. 字符串（`String`）类型由 Rust 标准库提供，而不是编入核心语言，它是一种可增长、可变、可拥有、UTF-8 编码的字符串类型。
4.  `String` 和 字符串 slices 都是 UTF-8 编码的。



### 新建字符串

1. 新建一个空的String：

```rust
fn main() {
    let mut s = String::new();
}
```



2. to_string方法，能用于任何实现了 `Display` trait 的类型，比如字符串字面值。

```rust
fn main() {
    let data = "initial contents";

    let s = data.to_string();

    // 该方法也可直接用于字符串字面值：
    let s = "initial contents".to_string();
}
```



3. 使用 `String::from` 函数来从字符串字面值创建 `String`

```rust
fn main() {
    let s = String::from("initial contents");
}
```



### 更新字符串

1. `String` 的大小可以增加，其内容也可以改变，就像可以放入更多数据来改变 `Vec` 的内容一样。
2. 另外，可以方便的使用 `+` 运算符或 `format!` 宏来拼接 `String` 值。

#### 使用 push_str 和 push 附加字符串

1. `push_str` 方法采用字符串 slice，因为我们并不需要获取参数的所有权。

```rust
fn main() {
    let mut s = String::from("foo");
    s.push_str("bar");
}

fn main() {
    let mut s1 = String::from("foo");
    let s2 = "bar";
    s1.push_str(s2); // 不获得s2的所有权
    println!("s2 is {s2}");
}
```



2. `push` 方法被定义为获取一个单独的字符作为参数，并附加到 `String` 中。

```rust
fn main() {
    let mut s = String::from("lo");
    s.push('l');
}
```



#### 使用 + 运算符或 format! 宏拼接字符串

1. `+` 运算符使用了 `add` 函数，这个函数签名看起来像这样：

```rust
//  add 获取了 self 的所有权
fn add(self, s: &str) -> String {}
```



2. 意味着
   1. 第一个参数被移动了，不能继续使用
   2. 我们使用第二个字符串的 **引用** 与第一个字符串相加。
   3. 实际上这个语句会获取 `s1` 的所有权，附加上从 `s2` 中拷贝的内容，并返回结果的所有权。换句话说，它看起来好像生成了很多拷贝，不过实际上并没有：这个实现比拷贝要更高效。

```rust
// example
fn main() {
    let s1 = String::from("Hello, ");
    let s2 = String::from("world!");
    
    //  add 获取了 self 的所有权，故而s1的所有权被移动到add调用
    // &String 可以被 强转（coerced）成 &str
    // 当add函数被调用时，Rust 使用了一个被称为 Deref 强制转换（deref coercion）的技术，你可以将其理解为它把 &s2 变成了 &s2[..]。
    // 故而可以传入 &s2
    let s3 = s1 + &s2; // 注意 s1 被移动了，不能继续使用
}
```



3. 如果想要级联多个字符串，可以使用  `format!` 宏：
   - `format!` 与 `println!` 的工作原理相同，不过不同于将输出打印到屏幕上，它返回一个带有结果内容的 `String`。
   - 宏 `format!` 生成的代码使用引用所以不会获取任何参数的所有权。

```rust
fn main() {
    let s1 = String::from("tic");
    let s2 = String::from("tac");
    let s3 = String::from("toe");

    let s = format!("{s1}-{s2}-{s3}");
}
```



### 索引字符串

1. 在 Rust 中，如果尝试使用索引语法访问 `String` 的一部分，会出现一个错误；这说明Rust 的字符串不支持索引。
2. rust的String不支持索引和其内部实现有关；且一个字符串字节值的索引并不总是对应一个有效的 Unicode 标量值。

```rust
fn main() {
    let s1 = String::from("hello");
    let h = s1[0]; // err
}
```



#### 内部表现

1. `String` 是一个 `Vec<u8>` 的封装。

```rust
fn main() {
    let hello = String::from("Hola"); 
    // len == 4, 这意味着储存字符串 “Hola” 的 Vec 的长度是四个字节：这里每一个字母的 UTF-8 编码都占用一个字节。
    
    let hello2 = String::from("Здравствуйте"); 
    // len == 24, 这是使用 UTF-8 编码 “Здравствуйте” 所需要的字节数，这是因为每个 Unicode 标量值需要两个字节存储。
    // 因此一个字符串字节值的索引并不总是对应一个有效的 Unicode 标量值。
    
    let answer = &hello2[0]; // err
    // answer 不是第一个字符 3。
    // 当使用 UTF-8 编码时，（西里尔字母的 Ze）З 的第一个字节是 208，第二个是 151，所以 answer 实际上应该是 208，不过 208 自身并不是一个有效的字母。
    // 返回 208 可不是一个请求字符串第一个字母的人所希望看到的，不过它是 Rust 在字节索引 0 位置所能提供的唯一数据。用户通常不会想要一个字节值被返回。
    // 即使这个字符串只有拉丁字母，如果 &"hello"[0] 是返回字节值的有效代码，它也会返回 104 而不是 h。
    // 为了避免返回意外的值并造成不能立刻发现的 bug，Rust 根本不会编译这些代码，并在开发过程中及早杜绝了误会的发生。
}
```



#### 字节、标量值和字形簇！天呐！

1. 从 Rust 的角度来讲，事实上有三种相关方式可以理解字符串：字节、标量值和字形簇（最接近人们眼中 **字母** 的概念）。
2. Rust 提供了多种不同的方式来解释计算机储存的原始字符串数据，这样程序就可以选择它需要的表现方式，而无所谓是何种人类语言。
3. 最后一个 Rust 不允许使用索引获取 `String` 字符的原因是，索引操作预期总是需要常数时间（O(1)）。但是对于 `String` 不可能保证这样的性能，因为 Rust 必须从开头到索引位置遍历来确定有多少有效的字符。



### 字符串slice

> 应该小心谨慎地使用这个操作，因为这么做可能会使你的程序崩溃。

1. 索引字符串通常是一个坏点子，因为字符串索引应该返回的类型是不明确的：字节值、字符、字形簇或者字符串 slice。

2. 因此，如果真的希望使用索引创建字符串 slice 时，Rust 会要求更明确一些。

   为了更明确索引并表明你需要一个字符串 slice，相比使用 `[]` 和单个值的索引，可以使用 `[]` 和一个 range 来创建含特定字节的字符串 slice：

```rust
#![allow(unused)]
fn main() {
    let hello = "Здравствуйте";

    let s = &hello[0..4]; // 这里，s 会是一个 &str，它包含字符串的头四个字节。早些时候，我们提到了这些字母都是两个字节长的，所以这意味着 s 将会是 “Зд”。
    
    // 如果获取 &hello[0..1] 会发生什么呢？答案是：Rust 在运行时会 panic，就跟访问 vector 中的无效索引时一样：
}
```



### 遍历字符串的方法

1. 操作字符串每一部分的最好的方法是明确表示需要字符还是字节。
2. 对于单独的 Unicode 标量值使用 `chars` 方法。

```rust
// 对 “Зд” 调用 `chars` 方法会将其分开并返回两个 `char` 类型的值，接着就可以遍历其结果来访问每一个元素了
for c in "Зд".chars() {
    println!("{c}");
}
```



3. 另外 `bytes` 方法返回每一个原始字节：

```rust
for b in "Зд".bytes() {
    println!("{b}");
}
```



### 字符串并不简单

1. 必须更多的思考如何预先处理 UTF-8 数据。
2.  `contains` 来搜索一个字符串。
3.  `replace` 将字符串的一部分替换为另一个字符串。



## 8.3 使用Hah Map存储键值对

1. `HashMap<K, V>` 类型储存了一个键类型 `K` 对应一个值类型 `V` 的映射；它通过一个 **哈希函数**（*hashing function*）来实现映射，决定如何将键和值放入内存中。
2. 哈希 map 可以用于需要任何类型作为键来寻找数据的情况，而不是像 vector 那样通过索引。



### 新建一个哈希map

1. 可以使用 `new` 创建一个空的 `HashMap`，并使用 `insert` 增加元素。
2. 像 vector 一样，哈希 map 将它们的数据储存在堆上。
3. 类似于 vector，哈希 map 是同质的：所有的键必须是相同类型，值也必须都是相同类型。

```rust
fn main() {
    // 注意必须首先 use 标准库中集合部分的 HashMap。
    use std::collections::HashMap;

    let mut scores = HashMap::new();

    // 这个 HashMap 的键类型是 String 而值类型是 i32。
    scores.insert(String::from("Blue"), 10);
    scores.insert(String::from("Yellow"), 50);

}
```



### 访问哈希map中的值

1. 可以通过 `get` 方法并提供对应的键来从哈希 map 中获取值：`get` 方法返回 `Option<&V>`，如果某个键在哈希 map 中没有对应的值，`get` 会返回 `None`。

```rust
fn main() {
    use std::collections::HashMap;

    let mut scores = HashMap::new();

    scores.insert(String::from("Blue"), 10);
    scores.insert(String::from("Yellow"), 50);

    let team_name = String::from("Blue");
    
    // 通过调用 copied 方法来获取一个 Option<i32> 而不是 Option<&i32>，
    // 接着调用 unwrap_or 在 scores 中没有该键所对应的项时将其设置为零
    let score = scores.get(&team_name).copied().unwrap_or(0);
}
```



### 哈希map和所有权

1. 对于像 `i32` 这样的实现了 `Copy` trait 的类型，其值可以拷贝进哈希 map。
2. 对于像 `String` 这样拥有所有权的值，其值将被移动而哈希 map 会成为这些值的所有者。
3. 如果将值的引用插入哈希 map，这些值本身将不会被移动进哈希 map。但是这些引用指向的值必须至少在哈希 map 有效时也是有效的。

```rust
fn main() {
    use std::collections::HashMap;

    let field_name = String::from("Favorite color");
    let field_value = String::from("Blue");

    let mut map = HashMap::new();
    map.insert(field_name, field_value);
    // 这里 field_name 和 field_value 不再有效，
    // 尝试使用它们看看会出现什么编译错误！
}
```



### 更新哈希map

1. 尽管键值对的数量是可以增长的，每个唯一的键只能同时关联一个值。
2. 当我们想要改变哈希 map 中的数据时，必须决定如何处理一个键已经有值了的情况。
   - 可以选择完全无视旧值并用新值代替旧值。
   - 可以选择保留旧值而忽略新值，并只在键 **没有** 对应值时增加新值。
   - 或者可以结合新旧两值。

#### 覆盖一个值

1. 插入了一个键值对，接着用相同的键插入一个不同的值，与这个键相关联的旧值将被替换。

```rust
fn main() {
    use std::collections::HashMap;

    let mut scores = HashMap::new();

    scores.insert(String::from("Blue"), 10);
    scores.insert(String::from("Blue"), 25);

    println!("{scores:?}"); // 25
}
```



#### 只在键没有对应值时插入键值对

1. 经常会检查某个特定的键是否已经存在于哈希 map 中并进行如下操作：如果哈希 map 中键已经存在则不做任何操作。如果不存在则连同值一块插入。
2. 哈希 map 有一个特有的 API，叫做 `entry`，它获取我们想要检查的键作为参数。`entry` 函数的返回值是一个枚举，`Entry`，它代表了可能存在也可能不存在的值。
3. `Entry` 的 `or_insert` 方法在键对应的值存在时就返回这个值的可变引用，如果不存在则将参数作为新值插入并返回新值的可变引用。

```rust
fn main() {
    // 比如说我们想要检查黄队的键是否关联了一个值。如果没有，就插入值 50，对于蓝队也是如此。
    use std::collections::HashMap;

    let mut scores = HashMap::new();
    scores.insert(String::from("Blue"), 10);

    scores.entry(String::from("Yellow")).or_insert(50); // 第一个 entry 调用会插入黄队的键和值 50，因为黄队并没有一个值。
    scores.entry(String::from("Blue")).or_insert(50); // 第二个 entry 调用不会改变哈希 map 因为蓝队已经有了值 10。

    println!("{scores:?}");

}
```



#### 根据旧值更新一个值

1. 另一个常见的哈希 map 的应用场景是找到一个键对应的值并根据旧的值更新它。

```rust
fn main() {
    // 计数一些文本中每一个单词分别出现了多少次
    // 使用哈希 map 以单词作为键并递增其值来记录我们遇到过几次这个单词。如果是第一次看到某个单词，就插入值 0。
    use std::collections::HashMap;

    let text = "hello world wonderful world";

    let mut map = HashMap::new();

    // split_whitespace 方法返回一个由空格分隔 text 值子 slice 的迭代器。
    for word in text.split_whitespace() {
        // or_insert 方法返回这个键的值的一个可变引用（&mut V）。
        // 这里我们将这个可变引用储存在 count 变量中，所以为了赋值必须首先使用星号（*）解引用 count。
        // 这个可变引用在 for 循环的结尾离开作用域，这样所有这些改变都是安全的并符合借用规则。
        let count = map.entry(word).or_insert(0);
        *count += 1;
    }

    println!("{map:?}"); //  {"world": 2, "hello": 1, "wonderful": 1}。
}
```



### 哈希函数

1. HashMap 默认使用一种叫做 SipHash 的哈希函数，它可以抵御涉及哈希表（hash table）的拒绝服务（Denial of Service, DoS）攻击。然而这并不是可用的最快的算法，不过为了更高的安全性值得付出一些性能的代价。
2. 可以指定一个不同的 *hasher* 来切换为其它函数。hasher 是一个实现了 `BuildHasher` trait 的类型。

