# 9 错误处理

1. Rust 将错误分为两大类：**可恢复的**（*recoverable*）和 **不可恢复的**（*unrecoverable*）错误。
   - 对于一个可恢复的错误，比如文件未找到的错误，我们很可能只想向用户报告问题并重试操作。
   - 不可恢复的错误总是 bug 出现的征兆，比如试图访问一个超过数组末端的位置，因此我们要立即停止程序。
2. 大多数语言并不区分这两种错误，并采用类似异常这样方式统一处理它们。Rust 没有异常。相反，它有 `Result<T, E>` 类型，用于处理可恢复的错误，还有 `panic!` 宏，在程序遇到不可恢复的错误时停止执行。



## 9.1 用 panic! 处理不可恢复的错误

1. 在实践中有两种方法造成 panic：

   - 执行会造成代码 panic 的操作（比如访问超过数组结尾的内容）
   - 或者显式调用 `panic!` 宏。

   这两种情况都会使程序 panic。

2. 通常情况下这些 panic 会打印出一个错误信息，展开并清理栈数据，然后退出。

3. 通过一个环境变量，也可以让 Rust 在 panic 发生时打印调用堆栈（call stack）以便于定位 panic 的原因。

4. 对应 panic 时的栈展开或终止：

   1. 当出现 panic 时，程序默认会开始 **展开**（*unwinding*），这意味着 Rust 会回溯栈并清理它遇到的每一个函数的数据，不过这个回溯并清理的过程有很多工作。
   2. 另一种选择是直接 **终止**（*abort*），这会不清理数据就退出程序。那么程序所使用的内存需要由操作系统来清理。
   3. 如果你需要项目的最终二进制文件越小越好，panic 时通过在 *Cargo.toml* 的 `[profile]` 部分增加 `panic = 'abort'`，可以由展开切换为终止。

```toml
[profile.release]
panic = 'abort'
```



5. 例子：

   错误信息报告的文件名和行号可能指向别人代码中的 `panic!` 宏调用，而不是我们代码中最终导致 `panic!` 的那一行。我们可以使用 `panic!` 被调用的函数的 backtrace 来寻找代码中出问题的地方。

```rust
fn main() {
    panic!("crash and run");
    /*
    // 第一行显示了 panic 提供的信息并指明了源码中 panic 出现的位置
    thread 'main' panicked at src/main.rs:2:5:
	// 自定义提示信息
	crash and run
	note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace
	error: process didn't exit successfully: `target\debug\panic-learning.exe` (exit code: 101)
    */
}
```



### 使用 panic! 的 backtrace

```rust
fn main() {
    // 因为代码中的 bug 引起的别的库中 panic! 的例子
    let v = vec![1, 2, 3];
    v[99];
}
```



1. 普通cargo run

```sh
thread 'main' panicked at src/main.rs:4:6: 
index out of bounds: the len is 3 but the index is 99
# 错误指向 main.rs 的第 4 行，这里我们尝试访问索引 99。
	
note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace 
# 提醒我们可以设置 RUST_BACKTRACE 环境变量来得到一个 backtrace。backtrace 是一个执行到目前位置所有被调用的函数的列表。
# Rust 的 backtrace 跟其他语言中的一样：阅读 backtrace 的关键是从头开始读直到发现你编写的文件。这就是问题的发源地。这一行往上是你的代码所调用的代码；往下则是调用你的代码的代码。这些行可能包含核心 Rust 代码，标准库代码或用到的 crate 代码。
	
error: process didn't exit successfully: `target\debug\panic-learning.exe` (exit code: 101)
```



2. 设置RUST_BACKTRACE变量

```sh
RUST_BACKTRACE=1 cargo run
$env:RUST_BACKTRACE=1; cargo run # (windows, powershell)

thread 'main' panicked at src/main.rs:4:6:
index out of bounds: the len is 3 but the index is 99
stack backtrace:
   0: std::panicking::begin_panic_handler
             at /rustc/f6e511eec7342f59a25f7c0534f1dbea00d01b14\library/std\src\panicking.rs:662
   1: core::panicking::panic_fmt
             at /rustc/f6e511eec7342f59a25f7c0534f1dbea00d01b14\library/core\src\panicking.rs:74
   2: core::panicking::panic_bounds_check
             at /rustc/f6e511eec7342f59a25f7c0534f1dbea00d01b14\library/core\src\panicking.rs:276
   3: core::slice::index::impl$2::index<i32>
             at /rustc/f6e511eec7342f59a25f7c0534f1dbea00d01b14\library\core\src\slice\index.rs:302
   4: alloc::vec::impl$13::index<i32,usize,alloc::alloc::Global>
             at /rustc/f6e511eec7342f59a25f7c0534f1dbea00d01b14\library\alloc\src\vec\mod.rs:2920
   5: panic_learning::main
             at .\src\main.rs:4 # backtrace 指出项目中造成问题的行：src/main.rs 的第 4 行, 排除问题从这里开始
   6: core::ops::function::FnOnce::call_once<void (*)(),tuple$<> >
             at /rustc/f6e511eec7342f59a25f7c0534f1dbea00d01b14\library\core\src\ops\function.rs:250
   7: core::hint::black_box
             at /rustc/f6e511eec7342f59a25f7c0534f1dbea00d01b14\library\core\src\hint.rs:388   
note: Some details are omitted, run with `RUST_BACKTRACE=full` for a verbose backtrace.        
error: process didn't exit successfully: `target\debug\panic-learning.exe` (exit code: 101)
```



3. 为了获取带有这些信息的 backtrace，必须启用 debug 标识。当不使用 `--release` 参数运行 cargo build 或 cargo run 时 debug 标识会默认启用。



## 9.2 用Result处理可恢复错误

1. 大部分错误并没有严重到需要程序完全停止执行。有时候，一个函数失败，仅仅就是因为一个容易理解和响应的原因。例如，如果因为打开一个并不存在的文件而失败，此时可能想要创建这个文件，而不是终止进程。

2. Result 枚举定义：

   `T` 和 `E` 是泛型类型参数， `T` 代表成功时返回的 `Ok` 成员中的数据的类型，而 `E` 代表失败时返回的 `Err` 成员中的错误的类型。

   因为 `Result` 有这些泛型类型参数，所以可以将 `Result` 类型和标准库中为其定义的函数用于很多不同的场景，这些情况中需要返回的成功值和失败值可能会各不相同。

```rust
enum Result<T, E> {
    Ok(T),
    Err(E),
}

// example: 打开一个文件
use std::fs::File;

fn main() {
    // File::open 的返回值是 Result<T, E>。
    // 泛型参数 T 会被 File::open 的实现放入成功返回值的类型 std::fs::File，这是一个文件句柄。
    // 错误返回值使用的 E 的类型是 std::io::Error。
    // 这些返回类型意味着 
    // File::open 调用可能成功并返回一个可以读写的文件句柄。
    // 这个函数调用也可能会失败：例如，也许文件不存在，或者可能没有权限访问这个文件。
    // File::open 函数需要一个方法在告诉我们成功与否的同时返回文件句柄或者错误信息。这些信息正好是 Result 枚举所代表的。
    // 当 File::open 成功时，greeting_file_result 变量将会是一个包含文件句柄的 Ok 实例。
    // 当失败时，greeting_file_result 变量将会是一个包含了更多关于发生了何种错误的信息的 Err 实例。
    let greeting_file_result = File::open("hello.txt");

    // 使用match处理File::open返回值
    let _greeting_file = match greeting_file_result {
        // 返回 Ok 成员中的 file 值，然后将这个文件句柄赋值给变量 greeting_file。match 之后，我们可以利用这个文件句柄来进行读写。
        Ok(file) => file, 
        Err(error) => panic!("Problem opening the file: {error:?}"),
    };
}
```



### 匹配不同的错误

```rust
use std::{fs::File, io::ErrorKind};

// File::open 返回的 Err 成员中的值类型 io::Error，它是一个标准库中提供的结构体。这个结构体有一个返回 io::ErrorKind 值的 kind 方法可供调用。io::ErrorKind 是一个标准库提供的枚举，它的成员对应 io 操作可能导致的不同错误类型。

fn main() {
    let filepath = "hello.txt";
    let _greeting_file = match File::open(filepath) {
        Ok(file) => file,
        Err(error) => match error.kind() {
            // 如果 File::open 因为文件不存在而失败，我们希望创建这个文件并返回新文件的句柄。
            // 如果 File::open 因为任何其他原因失败，则panic!。
            
            // ErrorKind::NotFound，代表尝试打开的文件并不存在
            ErrorKind::NotFound => match File::create(filepath) {
                Ok(fc) => fc,
                Err(e) => panic!("Problem creating the file: {e:?}"),
            }
            other_error => panic!("Problem opening the file: {other_error:?}")
        },
    };
}

// 使用闭包而不是match
fn main() {
    // 使用闭包
    let filepath = "hello.txt";
    let _greeting_file = File::open(filepath).unwrap_or_else(|error| {
        if error.kind() == ErrorKind::NotFound {
            File::create(filepath).unwrap_or_else(|error| {
                panic!("Problem creating the file: {:?}", error);
            })
        }
        else {
            panic!("Problem open the file: {:?}", error);
        }
    });
}
```



### 失败时panic的简写：unwrap和expect

1. `match` 能够胜任它的工作，不过它可能有点冗长并且不总是能很好的表明其意图。
2. `Result<T, E>` 类型定义了很多辅助方法来处理各种情况。其中之一叫做 `unwrap`，它的实现是：
   1. 如果 `Result` 值是成员 `Ok`，`unwrap` 会返回 `Ok` 中的值。
   2. 如果 `Result` 是成员 `Err`，`unwrap` 会为我们调用 `panic!`。

```rust
use std::fs::File;

fn main() {
    let greeting_file = File::open("hello.txt").unwrap();
}
```



3. 还有另一个类似于 `unwrap` 的方法它还允许我们选择 `panic!` 的错误信息：`expect`。使用 `expect` 而不是 `unwrap` 并提供一个好的错误信息可以表明你的意图并更易于追踪 panic 的根源。
4. `expect` 与 `unwrap` 的使用方式一样：返回文件句柄或调用 `panic!` 宏。`expect` 在调用 `panic!` 时使用的错误信息将是我们传递给 `expect` 的参数，而不像 `unwrap` 那样使用默认的 `panic!` 信息。
5. 在生产级别的代码中，大部分 Rustaceans 选择 `expect` 而不是 `unwrap` 并提供更多关于为何操作期望是一直成功的上下文。

```rust
use std::fs::File;

fn main() {
    let greeting_file = File::open("hello.txt")
        .expect("hello.txt should be included in this project");
}
```



### 传播错误

1. 当编写一个其实先会调用一些可能会失败的操作的函数时，除了在这个函数中处理错误外，还可以选择让调用者知道这个错误并决定该如何处理。这被称为 **传播**（*propagating*）错误，这样能更好的控制代码调用

```rust
use std::{fs::File, io::{self, ErrorKind, Read}};

// 从文件中读取用户名的函数。如果文件不存在或不能读取，这个函数会将这些错误返回给调用它的代码

// 函数的返回值：Result<String, io::Error>。
// 这意味着函数返回一个 Result<T, E> 类型的值，其中泛型参数 T 的具体类型是 String，而 E 的具体类型是 io::Error。
// 如果这个函数没有出任何错误成功返回，函数的调用者会收到一个包含 String 的 Ok 值 —— 函数从文件中读取到的用户名。
// 如果函数遇到任何错误，函数的调用者会收到一个 Err 值，它储存了一个包含更多这个问题相关信息的 io::Error 实例。
// 这里选择 io::Error 作为函数的返回值是因为它正好是函数体中那两个可能会失败的操作的错误返回值：File::open 函数和 read_to_string 方法。
fn read_username_from_file() -> Result<String, io::Error> {
    let filepath = "hello.txt";

    let mut file = match File::open(filepath) {
        Ok(f) => f,
        // 在 Err 的情况下，我们没有调用 panic!，而是使用 return 关键字提前结束整个函数，并将来自 File::open 的错误值（现在在模式变量 e 中）作为函数的错误值传回给调用者。
        Err(error) => return Err(e),
    };
    let mut username = String::new();
    
    // read_to_string 方法也返回一个 Result，因为它可能会失败，哪怕是 File::open 已经成功了。
    // 因此，我们需要另一个 match 来处理这个 Result：
    // 如果 read_to_string 执行成功，那么这个函数也就成功了，我们将从文件中读取的用户名返回，此时用户名位于被封装进 Ok 的 username 中。
    // 如果 read_to_string 执行失败，则像之前处理 File::open 的返回值的 match 那样返回错误值。
    match file.read_to_string(&mut username) {
        Ok(_) => Ok(username),
        Err(e) => Err(e),
    }
}
```



### 传播错误的简写：？运算符

1. Result 值之后的 ? 被定义为与上例的处理 Result 值的 match 表达式有着完全相同的工作方式。

   1. 如果 Result 的值是 Ok，这个表达式将会返回 Ok 中的值而程序将继续执行。
   2. 如果值是 Err，Err 将作为整个函数的返回值，就好像使用了 return 关键字一样，这样错误值就被传播给了调用者。

2.  `match` 表达式与 `?` 运算符所做的有一点不同：`?` 运算符所使用的错误值被传递给了 `from` 函数，它定义于标准库的 `From` trait 中，其用来将错误从一种类型转换为另一种类型。

   当 `?` 运算符调用 `from` 函数时，收到的错误类型被转换为由当前函数返回类型所指定的错误类型。这在当函数返回单个错误类型来代表所有可能失败的方式时很有用，即使其可能会因很多种原因失败。

3. 例如可以将下列的 read_username_from_file 函数修改为返回一个自定义的 OurError 错误类型。

   如果也定义了 `impl From<io::Error> for OurError` 来从 `io::Error` 构造一个 `OurError` 实例，那么 `read_username_from_file` 函数体中的 `?` 运算符调用会调用 `from` 并转换错误而无需在函数中增加任何额外的代码。

```rust
use std::{fs::File, io::{self, ErrorKind, Read}};

fn read_username_from_file() -> Result<String, io::Error> {
    let filepath = "hello.txt";

    // File::open 调用结尾的 ? 会将 Ok 中的值返回给变量 username_file。
    // 如果发生了错误，? 运算符会使整个函数提前返回并将任何 Err 值返回给调用代码。
    let mut file = File::open(filepath)?;
    let mut username = String::new();
    file.read_to_string(&mut username)?;
    return Ok(username);
}
```



4. `?` 运算符消除了大量样板代码并使得函数的实现更简单。我们甚至可以在 `?` 之后直接使用链式方法调用来进一步缩短代码

```rust
use std::{fs::File, io::{self, ErrorKind, Read}};

fn read_username_from_file() -> Result<String, io::Error> {
    let filepath = "hello.txt";
    let mut username = String::new();
    
    // 对 File::open(filepath)? 的结果直接链式调用了 read_to_string，而不再创建变量 username_file
    // 仍然需要 read_to_string 调用结尾的 ?
    File::open(filepath)?.read_to_string(&mut username)?;
    // 而且当 File::open 和 read_to_string 都成功没有失败时返回包含用户名 username 的 Ok 值。
    return Ok(username);
}
```



5. 将文件读取到一个字符串是相当常见的操作，所以 Rust 提供了名为 `fs::read_to_string` 的函数，它会打开文件、新建一个 `String`、读取文件的内容，并将内容放入 `String`，接着返回它。

```rust
use std::fs;
use std::io;

fn read_username_from_file() -> Result<String, io::Error> {
    let filepath = "hello.txt";
    return fs::read_to_string(filepath);
}
```



### 哪里可以使用 ? 运算符

1. `?` 运算符只能被用于返回值与 `?` 作用的值相兼容的函数。因为 `?` 运算符被定义为从函数中提早返回一个。
2. 如果返回的类型与 `?` 返回的类型不一致时，编译无法通过。
3.  `?` 也可用于 `Option<T>` 值。如同对 `Result` 使用 `?` 一样，只能在返回 `Option` 的函数中对 `Option` 使用 `?`。在 `Option<T>` 上调用 `?` 运算符的行为与 `Result<T, E>` 类似：
   - 如果值是 `None`，此时 `None` 会从函数中提前返回。
   - 如果值是 `Some`，`Some` 中的值作为表达式的返回值同时函数继续。

```rust
// 这个函数返回 Option<char> 因为它可能会在这个位置找到一个字符，也可能没有字符。
fn last_char_of_first_line(text: &str) -> Option<char> {
    // 这段代码获取 text 字符串 slice 作为参数并调用其 lines 方法，这会返回一个字符串中每一行的迭代器。
    // 因为函数希望检查第一行，所以调用了迭代器 next 来获取迭代器中第一个值。
    // 如果 text 是空字符串，next 调用会返回 None，此时我们可以使用 ? 来停止并从 last_char_of_first_line 返回 None。
    // 如果 text 不是空字符串，next 会返回一个包含 text 中第一行的字符串 slice 的 Some 值。
    // ? 会提取这个字符串 slice，然后可以在字符串 slice 上调用 chars 来获取字符的迭代器。
    // 我们感兴趣的是第一行的最后一个字符，所以可以调用 last 来返回迭代器的最后一项。
    // 这是一个 Option，因为有可能第一行是一个空字符串，例如 text 以一个空行开头而后面的行有文本，像是 "\nhi"。不过，如果第一行有最后一个字符，它会返回在一个 Some 成员中。
    // ? 运算符作用于其中给了我们一个简洁的表达这种逻辑的方式: 如果我们不能在 Option 上使用 ? 运算符，则不得不使用更多的方法调用或者 match 表达式来实现这些逻辑。
    text.lines().next()?.chars().last()
}
```



4. 可以在返回 `Result` 的函数中对 `Result` 使用 `?` 运算符，可以在返回 `Option` 的函数中对 `Option` 使用 `?` 运算符，但是不可以混合搭配。

   `?` 运算符不会自动将 `Result` 转化为 `Option`，反之亦然；在这些情况下，可以使用类似 `Result` 的 `ok` 方法或者 `Option` 的 `ok_or` 方法来显式转换。

5.  `main` 函数也可以返回 `Result<(), E>`。

6. main 函数也可以返回任何实现了 std::process::Termination trait 的类型，它包含了一个返回 ExitCode 的 report 函数。

```rust
use std::error::Error;
use std::fs::File;

// Box<dyn Error> 类型是一个 trait 对象
// 目前可以将 Box<dyn Error> 理解为 “任何类型的错误”。
// 在返回 Box<dyn Error> 错误类型 main 函数中对 Result 使用 ? 是允许的，因为它允许任何 Err 值提前返回。
// 即便 main 函数体从来只会返回 std::io::Error 错误类型，通过指定 Box<dyn Error>，这个签名也仍是正确的，甚至当 main 函数体中增加更多返回其他错误类型的代码时也是如此。
fn main() -> Result<(), Box<dyn Error>> {
    let greeting_file = File::open("hello.txt")?;

    // 当 main 函数返回 Result<(), E>，如果 main 返回 Ok(()) 可执行程序会以 0 值退出，而如果 main 返回 Err 值则会以非零值退出；
    // 成功退出的程序会返回整数 0，运行错误的程序会返回非 0 的整数。Rust 也会从二进制程序中返回与这个惯例相兼容的整数。
    Ok(())
}
```



## 9.3 要不要panic!

1. 如果代码 panic，就没有恢复的可能。

2. 可以选择对任何错误场景都调用 `panic!`，不管是否有可能恢复，不过这样就是代替调用者决定了这是不可恢复的。

   选择返回 `Result` 值的话，就将选择权交给了调用者，而不是代替他们做出决定。

3. 有些场景编译器无法认识这个分支代码是不可能走到的，但是程序员可以判断出来的，这种场景也可以用 panic!

4. 当有一些其他的逻辑来确保 `Result` 会是 `Ok` 值时，调用 `unwrap` 或者 `expect` 也是合适的，虽然编译器无法理解这种逻辑。仍然需要处理一个 `Result` 值：即使在你的特定情况下逻辑上是不可能的，你所调用的任何操作仍然有可能失败。

```rust
// 如果通过人工检查代码来确保永远也不会出现 Err 值，那么调用 unwrap 也是完全可以接受的
fn main() {
    use std::net::IpAddr;

    // 可以看出 127.0.0.1 是一个有效的 IP 地址，所以这里使用 expect 是可以接受的。
    // 然而，拥有一个硬编码的有效的字符串也不能改变 parse 方法的返回值类型：它仍然是一个 Result 值，而编译器仍然会要求我们处理这个 Result，好像还是有可能出现 Err 成员那样。
    let home: IpAddr = "127.0.0.1"
        .parse()
        .expect("Hardcoded IP address should be valid");
}
```



### 错误处理指导原则

1. 在当有可能会导致有害状态的情况下建议使用 `panic!` —— 在这里，有害状态是指当一些假设、保证、协议或不可变性被打破的状态，例如无效的值、自相矛盾的值或者被传递了不存在的值 —— 外加如下几种情况：
   1. 有害状态是非预期的行为，与偶尔会发生的行为相对，比如用户输入了错误格式的数据。
   2. 在此之后代码的运行依赖于不处于这种有害状态，而不是在每一步都检查是否有问题。
   3. 没有可行的手段来将有害状态信息编码进所使用的类型中的情况。
2. 如果别人调用你的代码并传递了一个没有意义的值，尽最大可能返回一个错误，如此库的用户就可以决定在这种情况下该如何处理。
3. 然而在继续执行代码是不安全或有害的情况下，最好的选择可能是调用 `panic!` 并警告库的用户他们的代码中有 bug，这样他们就会在开发时进行修复。
4. 类似的，如果你正在调用不受你控制的外部代码，并且它返回了一个你无法修复的无效状态，那么 `panic!` 往往是合适的。
5. 然而当错误预期会出现时，返回 `Result` 仍要比调用 `panic!` 更为合适。
6. 当代码在进行一个使用无效值进行调用时可能将用户置于风险中的操作时，代码应该首先验证值是有效的，并在其无效时 `panic!`。这主要是出于安全的原因：尝试操作无效数据会暴露代码漏洞，这就是标准库在尝试越界访问数组时会 `panic!` 的主要原因：尝试访问不属于当前数据结构的内存是一个常见的安全隐患。
7. 函数通常都遵循 **契约**（*contracts*）：它们的行为只有在输入满足特定条件时才能得到保证。当违反契约时 panic 是有道理的，因为这通常代表调用方的 bug，而且这也不是那种你希望所调用的代码必须处理的错误。



### 创建自定义类型进行有效性验证

```rust
// 创建类型用于检查参数范围：
pub struct Guess {
    value: i32,
}

impl Guess {
    // new 函数中代码的测试确保了其值是在 1 到 100 之间的。如果 value 没有通过测试则调用 panic!
    // 这会警告调用这个函数的程序员有一个需要修改的 bug，因为创建一个 value 超出范围的 Guess 将会违反 Guess::new 所遵循的契约。
    pub fn new(value: i32) -> Guess {
        if value < 1 || value > 100 {
            panic!("Guess value must be between 1 and 100, got {value}.");
        }

        Guess { value }
    }

    pub fn value(&self) -> i32 {
        self.value
    }
}
```



# 10 泛型、Trait和生命周期

1. 高效处理重复概念的工具之一。
2. 泛型是具体类型或其他属性的抽象替代。
3. 函数可以获取一些不同于 `i32` 或 `String` 这样具体类型的泛型参数，就像一个获取未知类型值的函数可以对多种具体类型的值运行同一段代码一样。
4.  **trait**，这是一个定义泛型行为的方法。trait 可以与泛型结合来将泛型限制为只接受拥有特定行为的类型，而不是任意类型。



### 提取函数来减少重复

1. 泛型允许我们使用一个可以代表多种类型的占位符来替换特定类型，以此来减少代码冗余。
2. 流程：
   1. 找出重复代码。
   2. 将重复代码提取到了一个函数中，并在函数签名中指定了代码中的输入和返回值。
   3. 将重复代码的两个实例，改为调用函数。

```rust
// 寻找最大值函数
// largest 函数有一个参数 list，它代表会传递给函数的任何具体的 i32值的 slice。
// 函数定义中的 list 代表任何 &[i32]。
fn largest(list: &[i32]) -> &i32 {
    let mut largest = &list[0];

    for item in list {
        if item > largest {
            largest = item;
        }
    }

    largest
}

fn main() {
    let number_list = vec![34, 50, 25, 100, 65];

    let result = largest(&number_list);
    println!("The largest number is {result}");

    let number_list = vec![102, 34, 6000, 89, 54, 2, 43, 8];

    let result = largest(&number_list);
    println!("The largest number is {result}");
}
```



## 10.1 泛型数据类型

1. 可以使用泛型为像函数签名或结构体这样的项创建定义，这样它们就可以用于多种不同的具体数据类型。



### 在函数定义中使用泛型

1. 当使用泛型定义函数时，本来在函数签名中指定参数和返回值的类型的地方，会改用泛型来表示。
2. 采用这种技术，使得代码适应性更强，从而为函数的调用者提供更多的功能，同时也避免了代码的重复。
3. 为了参数化泛型函数中的这些类型，我们需要为类型参数命名，道理和给函数的形参起名一样。任何标识符都可以作为类型参数的名字。例如使用 `T`。

```rust
// 函数泛型
// list: 元素为T的slice
// T: std::cmp::PartialOrd => 限制T只对实现了PartialOrd的类型有效
// 标准库中定义的 std::cmp::PartialOrd trait 可以实现类型的比较功能
fn largest<T: std::cmp::PartialOrd>(list: &[T]) -> &T {
    let mut largest = &list[0];
    for item in list {
        if item > largest {
            largest = item;
        }
    }
    return largest;
}

fn main() {
    let list = vec![34, 50, 25, 100, 65];
    let result = largest(&list);
    println!("The largest number is {result}");
    let list = vec!['y', 'm', 'a', 'q'];
    let result = largest(&list);
    println!("The largest number is {result}");
}
```



### 结构体定义中的泛型

1. 同样也可以用 `<>` 语法来定义结构体，它包含一个或多个泛型参数类型字段。
2. 首先，必须在结构体名称后面的尖括号中声明泛型参数的名称。接着在结构体定义中可以指定具体数据类型的位置使用泛型类型。

```rust
// 只使用了一个泛型类型，这个定义表明结构体 Point<T> 对于一些类型 T 是泛型的，
// 而且字段 x 和 y 都是 相同类型的，无论它具体是何类型
struct Point<T> {
    x: T,
    y: T,
}

fn main() {
    let integer = Point{ x: 5, y: 10, };
    let float = Point{ x: 1.0, y: 4.0 };
}
```



3. 可以使用多个泛型类型参数，可以在定义中使用任意多的泛型类型参数，不过太多的话，代码将难以阅读和理解。当发现代码中需要很多泛型时，这可能表明代码需要重构分解成更小的结构。

```rust
struct Point<T, U> {
    x: T,
    y: U,
}

fn main() {
    let integer = Point{ x: 5, y: 10.0, };
    let float = Point{ x: 1.0, y: 4.0 };
}
```



### 枚举定义中的泛型

1. 枚举也可以在成员中存放泛型数据类型

```rust
//  Option<T> 是一个拥有泛型 T 的枚举，它有两个成员：Some，它存放了一个类型 T 的值，和不存在任何值的None。
// 通过 Option<T> 枚举可以表达有一个可能的值的抽象概念，
// 同时因为 Option<T> 是泛型的，无论这个可能的值是什么类型都可以使用这个抽象。
enum Option<T> {
    Some(T),
    None,
}

// Result 枚举有两个泛型类型，T 和 E。
// Result 有两个成员：Ok，它存放一个类型 T 的值，而 Err 则存放一个类型 E 的值。
// 这个定义使得 Result 枚举能很方便的表达任何可能成功（返回 T 类型的值）也可能失败（返回 E 类型的值）的操作
enum Result<T, E> {
    Ok(T),
    Err(E),
}
```



### 方法定义中的泛型

1. 在为结构体和枚举实现方法时，一样也可以用泛型：
2. 注意必须在 `impl` 后面声明 `T`。
3. 可以为泛型参数选择一个与结构体定义中声明的泛型参数所不同的名称，不过依照惯例使用了相同的名称。

```rust
struct Point<T> {
    x: T,
    y: T,
}

// 注意必须在 impl 后面声明 T，这样就可以在 Point<T> 上实现的方法中使用 T 了。
// 通过在 impl 之后声明泛型 T，Rust 就知道 Point 的尖括号中的类型是泛型而不是具体类型。
// impl 中声明了泛型类型参数 T，x 是编写在 impl 中的方法，
// x 方法将会定义在 Point<T> 的任何实例上，无论最终替换泛型类型参数 T 的是何具体类型
impl<T> Point<T> {
    fn x(&self) -> &T {
        return &self.x;
    }
}
```



4. 定义方法时也可以为泛型指定限制

```rust
// 例如，可以选择为 Point<f32> 实例实现方法，而不是为泛型 Point 实例。
// 这段代码意味着 Point<f32> 类型会有一个方法 distance_from_origin，而其他 T 不是 f32 类型的 Point<T> 实例则没有定义此方法。
impl Point<f32> {
    fn distance_from_origin(&self) -> f32 {
        (self.x.powi(2) + self.y.powi(2)).sqrt()
    }
}
```



5. 结构体定义中的泛型类型参数并不总是与结构体方法签名中使用的泛型是同一类型

```rust
// 示例中为 Point 结构体使用了泛型类型 X1 和 Y1，
// 为 mixup 方法签名使用了 X2 和 Y2 来使得示例更加清楚。
// 这个方法用 self 的 Point 类型的 x 值（类型 X1）和参数的 Point 类型的 y 值（类型 Y2）来创建一个新 Point 类型的实例
struct Point<X1, Y1> {
    x: X1,
    y: Y1,
}

impl<X1, Y1> Point<X1, Y1> {
    fn mixup<X2, Y2>(self, other: Point<X2, Y2>) -> Point<X1, Y2> {
        return Point {
            x: self.x,
            y: other.y,
        };
    }
}

fn main() {
    let p1 = Point { x: 5, y: 10.4 };
    let p2 = Point { x: "Hello", y: 'c' };

    let p3 = p1.mixup(p2);

    println!("p3.x = {}, p3.y = {}", p3.x, p3.y); // p3.x = 5, p3.y = c
}
```



### 泛型代码的性能

1. 泛型并不会使程序比具体类型运行得慢。
2. Rust 通过在编译时进行泛型代码的 **单态化**（*monomorphization*）来保证效率。单态化是一个通过填充编译时使用的具体类型，将通用代码转换为特定代码的过程。
3. 编译器寻找所有泛型代码被调用的位置并使用泛型代码针对具体类型生成代码。
4. 因为 Rust 会将每种情况下的泛型代码编译为具体类型，使用泛型没有运行时开销。当代码运行时，它的执行效率就跟好像手写每个具体定义的重复代码一样。这个单态化过程正是 Rust 泛型在运行时极其高效的原因。



## 10.2 Trait：定义共同行为

1. *trait* 类似于其他语言中的常被称为 **接口**（*interfaces*）的功能，虽然有一些不同。
2. *trait* 定义了某个特定类型拥有可能与其他类型共享的功能。可以通过 trait 以一种抽象的方式定义共同行为。可以使用 *trait bounds* 指定泛型是任何拥有特定行为的类型。



### 定义trait

1. 一个类型的行为由其可供调用的方法构成。如果可以对不同类型调用相同的方法的话，这些类型就可以共享相同的行为了。

2. trait 定义是一种将方法签名组合起来的方法，目的是定义一个实现某些目的所必需的行为的集合。

3. *使用 trait 关键字来声明一个 trait，后面是 trait 的名字*。

   可以*声明 trait 为 pub 以便依赖这个 crate 的 crate 也可以使用这个 trait*。

4. 在大括号中声明描述实现这个 trait 的类型所需要的行为的方法签名；

   在方法签名后跟分号，而不是在大括号中提供其实现。
   接着每一个实现这个 trait 的类型都需要提供其自定义行为的方法体，
   trait 体中可以有多个方法：一行一个方法签名且都以分号结尾。

```rust
// aggregator库

// 例如，这里有多个存放了不同类型和属性文本的结构体：
// 结构体 NewsArticle 用于存放发生于世界各地的新闻故事，
// 而结构体 Tweet 最多只能存放 280 个字符的内容，以及像是否转推或是否是对推友的回复这样的元数据。

// 想要创建一个名为 aggregator 的多媒体聚合库用来显示可能储存在 NewsArticle 或 Tweet 实例中的数据摘要。

// 为了实现功能，每个结构体都要能够获取摘要，这样的话就可以调用实例的 summarize 方法来请求摘要。

// 一个表现这个概念的公有 Summary trait 的定义：
// Summary trait 定义，它包含由 summarize 方法提供的行为

// 使用 trait 关键字来声明一个 trait，后面是 trait 的名字，
// 在这个例子中是 Summary。
// 声明 trait 为 pub 以便依赖这个 crate 的 crate 也可以使用这个 trait
pub trait Summary {
    // 在大括号中声明描述实现这个 trait 的类型所需要的行为的方法签名
    // 在方法签名后跟分号，而不是在大括号中提供其实现。
    // 接着每一个实现这个 trait 的类型都需要提供其自定义行为的方法体，
    // 编译器也会确保任何实现 Summary trait 的类型都拥有与这个签名的定义完全一致的 summarize 方法。
    // trait 体中可以有多个方法：一行一个方法签名且都以分号结尾。
    fn summarize(&self) -> String;
}
```



### 为类型实现trait

1. 在类型上实现 trait 类似于实现常规方法。区别在于 `impl` 关键字之后，我们提供需要实现 trait 的名称，接着是 `for` 和需要实现 trait 的类型的名称。
2. 在 `impl` 块中，使用 trait 定义中的方法签名，不过不再后跟分号，而是需要在大括号中编写函数体来为特定类型实现 trait 方法所拥有的行为。

```rust
pub struct NewsArticle {
    pub headline: String,
    pub location: String,
    pub author: String,
    pub content: String,
}

//  NewsArticle 结构体上 Summary trait 的一个实现，
// 使用标题、作者和创建的位置作为 summarize 的返回值
impl Summary for NewsArticle {
    fn summarize(&self) -> String {
        format!("{}, by {} ({})", self.headline, self.author, self.location)
    }
}

pub struct Tweet {
    pub username: String,
    pub content: String,
    pub reply: bool,
    pub retweet: bool,
}

// Tweet 结构体将 summarize 定义为用户名后跟推文的全部文本作为返回值，并假设推文内容已经被限制为 280 字符以内
impl Summary for Tweet {
    fn summarize(&self) -> String {
        format!("{}: {}", self.username, self.content)
    }
}
```



3. crate 的用户可以像调用常规方法一样调用类型实例的 trait 方法了，唯一的区别是 trait 必须和类型一起引入作用域以便使用额外的 trait 方法。

```rust
// 例如使用上面定义的aggregator库crate：

//  trait 必须和类型一起引入作用域以便使用额外的 trait 方法
use aggregator::{Summary, Tweet};

fn main() {
    let tweet = Tweet {
        username: String::from("horse_ebooks"),
        content: String::from(
        	"of course, as you probably already know, people",
        ),
        reply: false,
        retweet: false,
    };
    
    println!("1 new tweet: {}", tweet.summarize());
}
```



4. 其他依赖 `aggregator` crate 的 crate 也可以将 `Summary` 引入作用域以便为其自己的类型实现该 trait。

   需要注意的限制是，只有在 trait 或类型至少有一个属于当前 crate 时，我们才能对类型实现该 trait。

   例如，可以为 `aggregator` crate 的自定义类型 `Tweet` 实现如标准库中的 `Display` trait，这是因为 `Tweet` 类型位于 `aggregator` crate 本地的作用域中。类似地，也可以在 `aggregator` crate 中为 `Vec<T>` 实现 `Summary`，这是因为 `Summary` trait 位于 `aggregator` crate 本地作用域中。

5. 相干性（孤儿规则，不存在父类型）：即不能为外部类型实现外部 trait。确保了其他人编写的代码不会破坏你代码。

   例如，不能在 `aggregator` crate 中为 `Vec<T>` 实现 `Display` trait。这是因为 `Display` 和 `Vec<T>` 都定义于标准库中，它们并不位于 `aggregator` crate 本地作用域中。



### 默认实现

1. 有时为 trait 中的某些或全部方法提供默认的行为，而不是在每个类型的每个实现中都定义自己的行为是很有用的。这样当为某个特定类型实现 trait 时，可以选择保留或重载每个方法的默认行为。
2. 在定义trait签名时，可以给一个默认值：

```rust
pub trait Summary {
    fn summarize(&self) -> String {
        String::from("(Read more...)")
    }
}
```



3. 对于想要使用默认实现的实例，可以通过 `impl Trait_Name for Type {}` 指定一个空的 `impl` 块。

```rust
// 虽然不再直接为 NewsArticle 定义 summarize 方法
// 但是提供了一个默认实现并且指定 NewsArticle 实现 Summary trait

impl Summary for NewsArticle {}

fn main() {
        let article = NewsArticle {
        headline: String::from("Penguins win the Stanley Cup Championship!"),
        location: String::from("Pittsburgh, PA, USA"),
        author: String::from("Iceburgh"),
        content: String::from(
            "The Pittsburgh Penguins once again are the best \
             hockey team in the NHL.",
        ),
    };

    println!("New article available! {}", article.summarize());
	// New article available! (Read more...)
}
```



4. 创建默认实现并不要求对其他 Type 上的 Trait 实现做任何改变。其原因是重载一个默认实现的语法与实现没有默认实现的 trait 方法的语法一样。
5. 默认实现允许调用相同 trait 中的其他方法，哪怕这些方法没有默认实现。如此，trait 可以提供很多有用的功能而只需要实现指定一小部分内容。

```rust
// 例如，可以定义 Summary trait，使其具有一个需要实现的 summarize_author 方法，
// 然后定义一个 summarize 方法，此方法的默认实现调用 summarize_author 方法
pub trait Summary {
    fn summarize_author(&self) -> String;

    fn summarize(&self) -> String {
        format!("(Read more from {}...)", self.summarize_author())
    }
}

// 为了使用这个版本的 Summary，只需在实现 trait 时定义 summarize_author 即可：
impl Summary for Tweet {
    fn summarize_author(&self) -> String {
        format!("@{}", self.username)
    }
}

// 一旦定义了 summarize_author，我们就可以对 Tweet 结构体的实例调用 summarize 了，
// 而 summarize 的默认实现会调用我们提供的 summarize_author 定义。
// 因为实现了 summarize_author，Summary trait 就提供了 summarize 方法的功能，且无需编写更多的代码。
fn main() {
        let tweet = Tweet {
        username: String::from("horse_ebooks"),
        content: String::from(
            "of course, as you probably already know, people",
        ),
        reply: false,
        retweet: false,
    };

    println!("1 new tweet: {}", tweet.summarize());
}
```



6. 注意无法从相同方法的重载实现中调用默认方法。



### trait作为参数

1. 如何使用 trait 来接受多种不同类型的参数。
2. 为此可以使用 `impl Trait` 语法：
3. 对于 `item` 参数，我们指定了 `impl` 关键字和 trait 名称，而不是具体的类型。该参数支持任何实现了指定 trait 的类型。

```rust
// 用Summary trait来定义了一个函数 notify 
// 来调用其参数 item 上的 summarize 方法，
// 该参数是实现了 Summary trait 的某种类型。

// 在 notify 函数体中，可以调用任何来自 Summary trait 的方法，比如 summarize。可以传递任何 NewsArticle 或 Tweet 的实例来调用 notify。
// 任何用其它如 String 或 i32 的类型调用该函数的代码都不能编译，因为它们没有实现 Summary。
pub fn notify(item: &impl Summary) {
    println!("Breaking news! {}", item.summarize());
}
```



### Trait Bound语法

1. trait bound 与泛型参数声明在一起，位于尖括号中的冒号后面。
2. `impl Trait` 语法更直观，但它实际上是更长形式的 *trait bound* 语法的语法糖。它看起来像：

```rust
pub fn notify<T: Summary>(item: &T) {
    println!("Breaking news! {}", item.summarize());
}
```



3. `impl Trait` 很方便，适用于短小的例子。更长的 trait bound 则适用于更复杂的场景。

```rust
// 例如，可以获取两个实现了 Summary 的参数。

// 使用 impl Trait 的语法看起来像这样：
// 这适用于 item1 和 item2 允许是不同类型的情况（只要它们都实现了 Summary）
pub fn notify(item1: &impl Summary, item2: &impl Summary) {}

// 不过如果希望强制它们都是相同类型呢？这只有在使用 trait bound 时才有可能
// 泛型 T 被指定为 item1 和 item2 的参数限制，如此传递给参数 item1 和 item2 值的具体类型必须一致。
pub fn notify<T: Summary>(item1: &T, item2: &T) {}
```



### 通过 + 指定多个 trait bound

1. 限定类型需要实现多个trait：

```rust
// 如果 notify 需要显示 item 的格式化形式，同时也要使用 summarize 方法，
// 那么 item 就需要同时实现两个不同的 trait：Display 和 Summary。这可以通过 + 语法实现：
pub fn notify(item: &(impl Summary + Display)) {}
```



2. `+` 语法也适用于泛型的 trait bound：

```rust
// 通过指定这两个 trait bound，notify 的函数体可以调用 summarize 并使用 {} 来格式化 item。

pub fn notify<T: Summary + Display>(item: &T) {}
```



### 通过 where 简化 trait bound

1. 使用过多的 trait bound 也有缺点。每个泛型有其自己的 trait bound，所以有多个泛型参数的函数在名称和参数列表之间会有很长的 trait bound 信息，这使得函数签名难以阅读。
2. Rust 有另一个在函数签名之后的 `where` 从句中指定 trait bound 的语法

```rust
fn some_function<T: Display + Clone, U: Clone + Debug>(t: &T, u: &U) -> i32 {}

// 使用where从句
fn some_function<T, U>(t: &T, u: &U) -> i32
where
    T: Display + Clone,
    U: Clone + Debug,
{}
```



### 返回实现了 trait 的类型

1. 也可以在返回值中使用 `impl Trait` 语法，来返回实现了某个 trait 的类型：

```rust
// 通过使用 impl Summary 作为返回值类型，指定了 returns_summarizable 函数返回某个实现了 Summary trait 的类型，但是不确定其具体的类型。
fn returns_summarizable() -> impl Summary {
    Tweet {
        username: String::from("horse_ebooks"),
        content: String::from(
            "of course, as you probably already know, people",
        ),
        reply: false,
        retweet: false,
    }
}
```



2. 返回一个只是指定了需要实现的 trait 的类型的能力在闭包和迭代器场景十分的有用：闭包和迭代器创建只有编译器知道的类型，或者是非常非常长的类型。
3. `impl Trait` 允许你简单的指定函数返回一个 `Iterator` 而无需写出实际的冗长的类型。
4. 只适用于返回单一类型的情况

```rust
// 例如，这段代码的返回值类型指定为返回 impl Summary，
// 但是返回了 NewsArticle 或 Tweet 就行不通
// 尝试返回 NewsArticle 或 Tweet。这不能编译，因为 impl Trait 工作方式的限制
fn returns_summarizable(switch: bool) -> impl Summary {
    if switch {
        NewsArticle {
            headline: String::from(
                "Penguins win the Stanley Cup Championship!",
            ),
            location: String::from("Pittsburgh, PA, USA"),
            author: String::from("Iceburgh"),
            content: String::from(
                "The Pittsburgh Penguins once again are the best \
                 hockey team in the NHL.",
            ),
        }
    } else {
        Tweet {
            username: String::from("horse_ebooks"),
            content: String::from(
                "of course, as you probably already know, people",
            ),
            reply: false,
            retweet: false,
        }
    }
}
```



### 使用 trait bound 有条件地实现方法

1. 通过使用带有 trait bound 的泛型参数的 `impl` 块，可以有条件地只为那些实现了特定 trait 的类型实现方法。

```rust
// 类型 Pair<T> 总是实现了 new 方法并返回一个 Pair<T> 的实例
use std::fmt::Display;

struct Pair<T> {
    x: T,
    y: T,
}

impl<T> Pair<T> {
    // Self 是一个 impl 块类型的类型别名（type alias），在这里是 Pair<T>）
    fn new(x: T, y: T) -> Self {
        Self { x, y }
    }
}

// 在这一个 impl 块中，只有那些为 T 类型实现了 PartialOrd trait（来允许比较） 和 Display trait（来启用打印）的 Pair<T> 才会实现 cmp_display 方法
impl<T: Display + PartialOrd> Pair<T> {
    fn cmp_display(&self) {
        if self.x >= self.y {
            println!("The largest member is x = {}", self.x);
        } else {
            println!("The largest member is y = {}", self.y);
        }
    }
}
```



2. 也可以对任何实现了特定 trait 的类型有条件地实现 trait。

   对任何满足特定 trait bound 的类型实现 trait 被称为 *blanket implementations*，它们被广泛的用于 Rust 标准库中。

```rust
// 例如，标准库为任何实现了 `Display` trait 的类型实现了 `ToString` trait。这个 `impl` 块看起来像这样：
impl<T: Display> ToString for T {
    // --snip--
}

// 因为标准库有了这些 blanket implementation，我们可以对任何实现了 Display trait 的类型调用由 ToString 定义的 to_string 方法。
// 例如，可以将整型转换为对应的 String 值，因为整型实现了 Display：
let s = 3.to_string();
```



3. trait 和 trait bound 让我们能够使用泛型类型参数来减少重复，而且能够向编译器明确指定泛型类型需要拥有哪些行为。

   然后编译器可以利用 trait bound 信息检查代码中所用到的具体类型是否提供了正确的行为

   在动态类型语言中，如果我们调用了一个未定义的方法，会在运行时出现错误。

   Rust 将这些错误移动到了编译时，甚至在代码能够运行之前就强迫我们修复问题。

   另外，也无需编写运行时检查行为的代码，因为在编译时就已经检查过了。这样既提升了性能又不必放弃泛型的灵活性。



## 10.3 生命周期确保引用有效

1. 生命周期是另一类泛型。不同于确保类型有期望的行为，生命周期确保引用如预期一直有效。
2. Rust 中的每一个引用都有其 **生命周期**（*lifetime*），也就是引用保持有效的作用域。大部分时候生命周期是隐含并可以推断的，正如大部分时候类型也是可以推断的一样。
3. 类似于当因为有多种可能类型的时候必须注明类型，也会出现引用的生命周期以一些不同方式相关联的情况，所以 Rust 需要使用泛型生命周期参数来注明它们的关系，这样就能确保运行时实际使用的引用绝对是有效的。



### 生命周期避免了悬垂引用

1. 生命周期的主要目标是避免**悬垂引用**（*dangling references*），后者会导致程序引用了非预期引用的数据。
2. 借用检查器：Rust 编译器有一个 **借用检查器**（*borrow checker*），它比较作用域来确保所有的借用都是有效的。

```rust
fn main() {
    // 这里将 r 的生命周期标记为 'a 并将 x 的生命周期标记为 'b。
    // 内部的 'b 块要比外部的生命周期 'a 小得多。
    // 在编译时，Rust 比较这两个生命周期的大小，并发现 r 拥有生命周期 'a，不过它引用了一个拥有生命周期 'b 的对象。
    // 程序被拒绝编译，因为生命周期 'b 比生命周期 'a 要小：被引用的对象比它的引用者存在的时间更短。
    
    let r;                // ---------+-- 'a
                          //          |
    {                     //          |
        let x = 5;        // -+-- 'b  |
        r = &x;           //  |       |
    }                     // -+       |
                          //          |
    println!("r: {r}");   //          |
}                         // ---------+
```



### 函数中的泛型生命周期

1. 通过增加泛型生命周期参数来定义引用间的关系以便借用检查器可以进行分析。

```rust
// 当我们定义这个函数的时候，并不知道传递给函数的具体值，所以也不知道到底是 if 还是 else 会被执行。
// 我们也不知道传入的引用的具体生命周期，所以也就不能通过观察作用域来确定返回的引用是否总是有效。
// 借用检查器自身同样也无法确定，因为它不知道 x 和 y 的生命周期是如何与返回值的生命周期相关联的。
// 为了修复这个错误，可以通过增加泛型生命周期参数来定义引用间的关系以便借用检查器可以进行分析。
fn longest(x: &str, y: &str) -> &str {
    if x.len() > y.len() {
        x
    } else {
        y
    }
}
```



### 生命周期注解语法

1. 生命周期注解并不改变任何引用的生命周期的长短。相反它们描述了多个引用生命周期相互的关系，而不影响其生命周期。

2. 与当函数签名中指定了泛型类型参数后就可以接受任何类型一样，当指定了泛型生命周期后函数也能接受任何生命周期的引用。

3. 生命周期注解有着一个不太常见的语法：

   生命周期参数名称必须以撇号（`'`）开头，其名称通常全是小写，类似于泛型其名称非常短。大多数人使用 `'a` 作为第一个生命周期注解。生命周期参数注解位于引用的 `&` 之后，并有一个空格来将引用类型与生命周期注解分隔开。

```rust
&i32        // 引用
&'a i32     // 带有显式生命周期的引用
&'a mut i32 // 带有显式生命周期的可变引用
```



4. 单个的生命周期注解本身没有多少意义，因为生命周期注解告诉 Rust 多个引用的泛型生命周期参数如何相互联系的。
4. 如果函数有一个生命周期 `'a` 的 `i32` 的引用的参数 `first`。还有另一个同样是生命周期 `'a` 的 `i32` 的引用的参数 `second`。这两个生命周期注解意味着引用 `first` 和 `second` 必须与这泛型生命周期存在得一样久。



### 函数签名中的生命周期注解

1. 为了在函数签名中使用生命周期注解，需要在函数名和参数列表间的尖括号中声明泛型生命周期（*lifetime*）参数，就像泛型类型（*type*）参数一样。
2. 希望函数签名表达如下限制：也就是这两个参数和返回的引用存活的一样久。（两个）参数和返回的引用的生命周期是相关的。

```rust
// 现在函数签名表明
// 对于某些生命周期 'a，函数会获取两个参数，它们都是与生命周期 'a 存在的至少一样长的字符串 slice。
// 函数会返回一个同样也与生命周期 'a 存在的至少一样长的字符串 slice。
// 它的实际含义是 longest 函数返回的引用的生命周期与函数参数所引用的值的生命周期的较小者一致。
// 注意 longest 函数并不需要知道 x 和 y 具体会存在多久，而只需要知道有某个可以被 'a 替代的作用域将会满足这个签名。
fn longest<'a>(x: &'a str, y: &'a str) -> &'a str {
    if x.len() > y.len() {
        return x;
    }
    return y;
}

// 当具体的引用被传递给 longest 时，被 'a 所替代的具体生命周期是 x 的作用域与 y 的作用域相重叠的那一部分。
// 换一种说法就是泛型生命周期 'a 的具体生命周期等同于 x 和 y 的生命周期中较小的那一个。
// 因为我们用相同的生命周期参数 'a 标注了返回的引用值，所以返回的引用值就能保证在 x 和 y 中较短的那个生命周期结束之前保持有效。
```



3. 通过在函数签名中指定生命周期参数时，我们并没有改变任何传入值或返回值的生命周期，而是指出任何不满足这个约束条件的值都将被借用检查器拒绝。
4. 当在函数中使用生命周期注解时，这些注解出现在函数签名中，而不存在于函数体中的任何代码中。
5. 生命周期注解成为了函数约定的一部分，非常像签名中的类型。让函数签名包含生命周期约定意味着 Rust 编译器的工作变得更简单了。如果函数注解有误或者调用方法不对，编译器错误可以更准确地指出代码和限制的部分。

```rust
// result 的引用的生命周期必须是两个参数中较短的那个。
fn main() {
    let string1 = String::from("long string is long");
    let result;
    {
        let string2 = String::from("xyz");
        result = longest(string1.as_str(), string2.as_str());
    }
    println!("The longest string is {result}");
}
```



### 深入理解生命周期

1. 指定生命周期参数的正确方式依赖函数实现的具体功能。

```rust
// 例如，如果将 longest 函数的实现修改为总是返回第一个参数而不是最长的字符串 slice，就不需要为参数 y 指定一个生命周期。如下代码将能够编译：
// 为参数 x 和返回值指定了生命周期参数 'a，不过没有为参数 y 指定，因为 y 的生命周期与参数 x 和返回值的生命周期没有任何关系。
fn longest<'a>(x: &'a str, y: &str) -> &'a str {
    x
}
```



2. 当从函数返回一个引用，返回值的生命周期参数需要与一个参数的生命周期参数相匹配。

   如果返回的引用 **没有** 指向任何一个参数，那么唯一的可能就是它指向一个函数内部创建的值。然而它将会是一个悬垂引用，因为它将会在函数结束时离开作用域。

```rust
// 即便我们为返回值指定了生命周期参数 'a，这个实现却编译失败了，因为返回值的生命周期与参数完全没有关联。
fn longest<'a>(x: &str, y: &str) -> &'a str {
    let result = String::from("really long string");
    result.as_str()
}
```



### 结构体定义中的生命周期注解

1. 结构体也可以定义包含引用的结构体，不过这需要为结构体定义中的每一个引用添加生命周期注解。

```rust
// 结构体有唯一一个字段 part，它存放了一个字符串 slice，这是一个引用。
// 类似于泛型参数类型，必须在结构体名称后面的尖括号中声明泛型生命周期参数，以便在结构体定义中使用生命周期参数。
// 这个注解意味着 ImportantExcerpt 的实例不能比其 part 字段中的引用存在的更久。
struct ImportantExcerpt<'a> {
    part: &'a str,
}

fn main() {
    let novel = String::from("Call me Ishmael. Some years ago...");
    let first_sentence = novel.split('.').next().unwrap();
    let i = ImportantExcerpt {
        part: first_sentence
    };
}
```



### 生命周期省略

1. 被编码进 Rust 引用分析的模式被称为 **生命周期省略规则**，这些规则是一系列特定的场景，此时编译器会考虑，如果代码符合这些场景，就无需明确指定生命周期。，例如：

```rust
fn first_word(s: &str) -> &str {
    let bytes = s.as_bytes();

    for (i, &item) in bytes.iter().enumerate() {
        if item == b' ' {
            return &s[0..i];
        }
    }

    &s[..]
}

```



2. 函数或方法的参数的生命周期被称为 **输入生命周期**（*input lifetimes*），而返回值的生命周期被称为 **输出生命周期**（*output lifetimes*）。
3. 编译器采用三条规则来判断引用何时不需要明确的注解。第一条规则适用于输入生命周期，后两条规则适用于输出生命周期。如果编译器检查完这三条规则后仍然存在没有计算出生命周期的引用，编译器将会停止并生成错误。这些规则适用于 `fn` 定义，以及 `impl` 块。
   1. 第一条规则是编译器为每一个引用参数都分配一个生命周期参数。换句话说就是，函数有一个引用参数的就有一个生命周期参数：`fn foo<'a>(x: &'a i32)`，有两个引用参数的函数就有两个不同的生命周期参数，`fn foo<'a, 'b>(x: &'a i32, y: &'b i32)`，依此类推。
   2. 第二条规则是如果只有一个输入生命周期参数，那么它被赋予所有输出生命周期参数：`fn foo<'a>(x: &'a i32) -> &'a i32`。
   3. 第三条规则是如果方法有多个输入生命周期参数并且其中一个参数是 `&self` 或 `&mut self`，说明是个对象的方法 (method)，那么所有输出生命周期参数被赋予 `self` 的生命周期。

```rust
// example1
fn first_word(s: &str) -> &str {
    ;
}

// 应用第一条规则，也就是每个引用参数都有其自己的生命周期。
fn first_word<'a>(s: &'a str) -> &str {
    ;
}

// 对于第二条规则，因为这里正好只有一个输入生命周期参数所以是适用的。第二条规则表明输入参数的生命周期将被赋予输出生命周期参数，所以现在签名看起来像这样
fn first_word<'a>(s: &'a str) -> &'a str {
    ;
}

// example2
fn longest(x: &str, y: &str) -> &str {
    ;
}

// 应用第一条规则：每个引用参数都有其自己的生命周期。这次有两个参数，所以就有两个（不同的）生命周期：
fn longest<'a, 'b>(x: &'a str, y: &'b str) -> &str {
    ;
}

// 应用第二条规则，因为函数存在多个输入生命周期，它并不适用于这种情况。
// 第三条规则，它同样也不适用，这是因为没有 self 参数。
// 应用了三个规则之后编译器还没有计算出返回值类型的生命周期。故必须显式注明生命周期
```



### 方法定义中的生命周期注解

1. 当为带有生命周期的结构体实现方法时，其语法依然类似泛型类型参数的语法。在哪里声明和使用生命周期参数，取决于它们是与结构体字段相关还是与方法参数和返回值相关。
2. （实现方法时）结构体字段的生命周期必须总是在 `impl` 关键字之后声明并在结构体名称之后被使用，因为这些生命周期是结构体类型的一部分。
3. `impl` 块里的方法签名中，引用可能与结构体字段中的引用相关联，也可能是独立的。另外，生命周期省略规则也经常让我们无需在方法签名中使用生命周期注解。
4. `impl` 之后和类型名称之后的生命周期参数是必要的，不过因为第一条生命周期规则我们并不必须标注 `self` 引用的生命周期。

```rust
// 这里有一个方法 level。其唯一的参数是 self 的引用，而且返回值只是一个 i32，并不引用任何值
impl<'a> ImportantExcerpt<'a> {
    fn level(&self) -> i32 {
        3
    }
}

// 适用于第三条生命周期省略规则的例子
// 这里有两个输入生命周期，所以 Rust 应用第一条生命周期省略规则并给予 &self 和 announcement 它们各自的生命周期。
// 接着，因为其中一个参数是 &self，返回值类型被赋予了 &self 的生命周期，这样所有的生命周期都被计算出来了。
impl<'a> ImportantExcerpt<'a> {
    fn announce_and_return_part(&self, announcement: &str) -> &str {
        println!("Attention please: {announcement}");
        self.part
    }
}
```



### 静态生命周期

1. 有一种特殊的生命周期：`'static`，其生命周期**能够**存活于整个程序期间。所有的字符串字面值都拥有 `'static` 生命周期

```rust
// 这个字符串的文本被直接储存在程序的二进制文件中而这个文件总是可用的。
// 因此所有的字符串字面值都是 'static 的。
let s: &'static str = "I have a static lifetime.";
```



### 结合泛型类型参数、trait bounds 和生命周期

```rust
// 在同一函数中指定泛型类型参数、trait bounds 和生命周期的语法
use std::fmt::Display;

// 带有一个额外的参数 ann。
// ann 的类型是泛型 T，它可以被放入任何实现了 where 从句中指定的 Display trait 的类型。
// 这个额外的参数会使用 {} 打印，这也就是为什么 Display trait bound 是必须的。
// 因为生命周期也是泛型，所以生命周期参数 'a 和泛型类型参数 T 都位于函数名后的同一尖括号列表中。
fn longest_with_an_announcement<'a, T> (
    x: &'a str,
    y: &'a str,
    ann: T,
) -> &'a str
where 
    T: Display, 
{
    println!("Announcement! {ann}");
    if x.len() > y.len() {
        return x;
    }
    return y;
}
```



# 11 编写自动化测试



# -----------------------------其他



## static静态变量

1. 与const常量不同，static变量是在运行时分配内存的。
2. 并不是不可变，可以使用unsafe修改。（rust的unsafe和safe是完全隔离的）
3. 静态变量的生命周期为整个程序运行时间。
4. 命名建议全部大写，单词之间加入下划线。

```rust
static MY_STATIC: i32 = 42;
static mut MUT_STATIC: i32 = 42; // 可修改

fn main() {
    unsafe {
        MUT_STATIC = 32;
    }
    // 此时不能在safe代码里打印（使用）MUT_STATIC，原因是rust的unsafe和safe是完全隔离的，只能在unsafe使用它
}
```



## 类型转换 as

1. 一般来说，只能在可以安全转换的类型之间进行转换操作。

```rust
let a = 3.1;
let b = a as i32; //  浮点转整型
```





# 宏

1. 宏看起来像函数，但是名字以 `!` 结尾。
2. 宏的原理是在编译时产生代码。
3. 宏的调用方式看起来和函数类似。
4. 可以自定义宏。

## print!和println!

1. 用于输出文字信息。
2. 使用 `{}` 来做字符串插入，`{:?}` 做调试输出：数组和向量，可以使用调试输出来进行打印
3. `{}` 里可以加数组，表示第几个参数。也可以直接写入变量名。



## assert!和assert_eq!

1. 如果条件 condition 不成立，`assert!(condition )` 会导致 panic。
2. 如果 `left != right`，`assert_eq!(left, right)` 会导致 panic。
3. 用于测试和捕捉非法条件。



## unreachable!

1. 表示不会到达的代码分支。
2. 如果运行到就会造成 panic。

```rust
if false {
    unreachable!();
}
```



## implemented!

1. `panic!("not yet implemented")` 的简写。
2. 可用于标注还没有实现的功能。



2. 

