# 数据类型

## 前言

1. 数据类型是程序的基础，它告诉我们数据的意义以及我们能在数据上执行的操作。



## 基本数据类型

1. 除去布尔类型和扩展的字符型之外，其他整型可以划分位带符合的（signed）和无符号的（unsigned）两种。
2. int，short，long 和 long long 都是带符号的，在类型前面加上 unsigned 可以得到其无符号类型。unsigned int 可以缩写位 unsigned。
3. 字符型分为3种，char，signed char 和 unsigned char 三种，char 是 signed char 还是 unsigned char 取决于编译器。
4. 当明确知晓数值不可能为负时，应选用无符号类型。
5. 在满足需求的情况下，使用 int 执行整数运算，如果数值超过 int 范围，选用 long long。
6. 在算术表达式中不要使用 char 和 bool，只有存放字符或者布尔值时才使用。一个是 char 在一些机器是有符号的，有一些机器又是没符号的，所以使用 char 进行运算比较容易出问题。
7. 执行浮点数运算选用 double。



基本数据类型大小：

> c++标准规定基本数据类型的大小

| 类型        | 含义           | 最小尺寸                 | 备注                                                         |
| ----------- | -------------- | ------------------------ | ------------------------------------------------------------ |
| bool        | 布尔类型       | 未定义                   | true/false                                                   |
| char        | 字符           | 8位                      | 1. ascii，一般为1字节，一个char的空间应确保可以存放机器基本字符集对应的数字值。也就是说，一个char的大小应该和应该机器字节一样。（大多数机器的字节由8比特构成） |
| wchar_t     | 宽字符         | 16位                     | 用于确保可以存放机器最大扩展字符集中的任意一个字符。         |
| char16_t    | Unicode字符    | 16位                     | 为Unicode字符集服务（Unicode是用于表示所有自然语言中字符的标准） |
| char32_t    | Unicode字符    | 32位                     | 为Unicode字符集服务（Unicode是用于表示所有自然语言中字符的标准） |
| short       | 短整型         | 16位                     |                                                              |
| int         | 整型           | 16位                     | 至少和一个short一样大                                        |
| long        | 长整型         | 32位                     | 至少和一个int一样大                                          |
| long long   | 长整型         | 64位                     | 至少和一个long一样大，c++11新定义                            |
| float       | 单精度浮点数   | 6位有效数字，一般为7位   | 一般为1个字。（大多数机器的字由32或64比特构成，也就是4或8字节） |
| double      | 双精度浮点数   | 10位有效数字，一般为16位 | 一般为2个字。（大多数机器的字由32或64比特构成，也就是4或8字节） |
| long double | 扩展精度浮点数 | 10位有效数字             | 一般不使用，常被用于有特殊浮点需求的硬件，一般为3/4个字。（大多数机器的字由32或64比特构成，也就是4或8字节） |



## 类型转换

1. 类型所能表示的值的范围决定了转换的过程。
2. 布尔转为非布尔时，true 表示 1， false 表示 0。
3. 非布尔的算术值转为布尔时，非零表示 true，0 表示 false。
4. 浮点数赋予整数时，仅保留整数部分。
5. 整数赋予浮点数时，小数部分记为 0。
6. 给无符号整数值赋的值超过其范围的话，无符号整数保留的值为赋的值去模整数能表示。
7. 给带符号类型赋予一个超出其范围的值，该行为是未定义的，程序可能继续工作，也可能崩溃，也可能产生垃圾数据。
8. int 和 unsigned 一起运算时，int 会被隐式转换为 unsigned。
9. 无符号数减去一个数时，必须确保减完的结果大于等于0。
10. 尽量避免混用有符号数和无符号数进行运算。（有符号数为负数时，计算结果可能为垃圾数据）



## 字面值常量

1. 整型字面值具体的数据类型由它的值和符号决定，默认情况下，十进制字面值时带符号数，八进制和十六进制字面值即可能是带符合的也可能是无符号的。
2. 十进制字面值的类型是 int，long 和 long long中尺寸最小的那个，当然前提是这种类型能容纳下当前的值。
3. 八进制和十六进制的字面值类型是能容纳其数值的 int，unsigned int，long，unsigned long，long long 和 unsigned long long 中的尺寸最小者。
4. 如果一个字面值连与之关联的最大数据类型都放不下，将产生错误。
5. 类型 short 没有对应的字面值。
6. 浮点数字面值默认是 double。
7. 字符串字面值，编译器会在其末尾添加空字符 '\0'。分开书写字符串字面值可以如下

```cpp
std::cout << "Hello, " 
    "World!" << std::endl;
```

8. 指定字面值的类型：

| 前缀                | 后缀  | 类型        | 含义                        |
| ------------------- | ----- | ----------- | --------------------------- |
| **==字符/字符串==** |       |             |                             |
| u                   |       | char16_t    | Unicode16字符               |
| U                   |       | char32_t    | Unicode32字符               |
| L                   |       | wchar_t     | 宽字符                      |
| u8                  |       | char        | utf-8（仅用于字符串字面量） |
| **==整数==**        |       |             |                             |
|                     | u/U   | unsigned    |                             |
|                     | l/L   | long        |                             |
|                     | ll/LL | long long   |                             |
| **==浮点数==**      |       |             |                             |
|                     | f/F   | float       |                             |
|                     | l/L   | long double |                             |

```cpp
    L'A'		// 宽字符型字面值, wchar_t
    u8"Hi"		// utf-8字符串字面值，用8位编码一个Unicode字符
    42ULL		// unsigned long long
    1E-3F		// float
    3.14L		// long double
```



## 转义字符

1. 泛化转移序列：其形式是 \x 后紧跟一个或多个**十六进制数字**，或者 \ 后紧跟一个，两个或三个**八进制数字**，其中数字部分表示的是字符对应的数值。



## 引用

1. 引用一致无特别说明，指的是左值引用。
2. 定义引用时，是把引用和其初始值绑定在一起。必须初始化。
3. 引用并不是对象，只是为一个已存在的对象所起的另外一个名字。
4. 定义一个引用后，对其所有的操作都是在与之绑定的对象上进行的。
5. 不能定义引用的引用。
6. 允许一条语句定义多个引用，但必须标志符前面加上 & 符号。
7. 引用只能绑定在对象上，而不能绑定到字面值或某个表达式的结果（右值）上。
8. 引用的类型一般要和与之绑定的对象严格匹配。但也有例外：
    1. **在初始化常量引用（即以 const 修饰的引用）时允许用任意表达式作为初始值，只要该表达式结果能转换成引用的类型即可**。允许为一个常量引用绑定非常量的对象、字面值，甚至是个一般表达式。


```cpp
int i = 42;
const int &_i = i; // 正确, 允许将 const int& 绑定到一个普通 int 对象上
const int &n = 42; // 正确
double dval = 3.14;
const int &ri = dval; // 正确, 编译器会生成一个中间变量，实际是绑定到中间变量中。其过程如下：
#if 0
double dval = 3.14;
const int temp = dval;
const int &ri = temp; // 故而对dval的修改不影响 ri 引用的值。因为它绑定的是temp临时量
#endif
```



## 指针

1. 允许一条语句定义多个指针，但必须标志符前面加上 * 符号。

```cpp
int *p1 = nullptr, *p2 = nullptr;
```

2. 指针类型一般要和其指向的对象严格匹配。
3. 使用解引用符 * 来访问有效指针指向的对象
4. 建议初始化所有的指针。
5. 任何非 0 指针对应的条件值都为 true。
6. 空指针：

```cpp
int *p1 = nullptr, *p2 = NULL, *p3 = 0; // 等价, 推荐 nullptr, 必须是0, 不能是变量
```

7. 空类型指针 void*，可以存在任意对象的地址。
7. 声明时把 *，& 放在变量一侧：

```cpp
int i = 1024, *p = &i, &r = i; // int 是基本数据类型, *,& 是类型修饰符
```

9. 指向指针的引用：

```cpp
int *p = nullptr, *&r = p; // 从右往左读, &r表示r为引用, *号表示为指针引用。
```

10. 指向常量的指针可以指向非常量的对象。仅要求不能通过该指针改变指向的对象的值。
11. const 在 * 右侧，表示该指针是一个常量指针，不能改变其指向的对象。
    1. 顶层 const 表示指针本身是个常量，不能重新赋值。
    2. 底层 const 表示指针指向的对象是一个常量，不能修改其指向的对象的值。（取常量对象地址也是一种底层 const）

```cpp
int i = 0;
int *const p = &i; // p是常量指针，不能重新赋值。但可以修改其指向的对象的值
// const p 表示是一个常量对象
// int * 表示类型
*p = 2;

const int *p2 = &i; // 指向的类型是 const int, 表示指向的是常量类型, 不能修改其指向的对象的值，但指针可以指向其他对象
int i2 = 0;
p2 = &i2;

const int *const i = &i; // 即不能重新指向，也不能修改其指向的对象的值。
```



## 类型别名

1. 使用 `typedef`。
2. 使用 `using`。



## auto

1. auto 让编译器通过初始值来推算变量的类型，故 auto 变量必须由初始值。
2. auto 一般会忽略顶层 const，底层 const （指针）又会被保留。

```cpp
const int ci = 1;
auto b = ci; // 这里 auto 是 int
```

3. 可以用 const 修饰 auto 变量，表明是顶层 const。
4. 也可以有 auto 引用 auto&。



## decltype 类型指示符

1. 返回操作数的数据类型，在此过程中，编译器分析表达式并得到它的类型，却不实际计算表达式的值。

```cpp
decltype(f()) sum = f();
```

2. 如果 decltype 使用的表达式是一个变量，则 decltype 返回该变量的类型（包括顶层 const 和引用在内）。

```cpp
const int ci = 0, &cj = ci;
decltype(ci) x = 0; // const int
decltype(cj) y = x; // const int&
```

3. 如果 decltype 使用的表达式不是一个变量，则 decltype 返回表达式结果对应的类型。

```cpp
int i = 42, &r = i;
decltype(r + 0) b; // int
```

4. 如果表达式的结果是解引用，那么 decltype 将得到引用类型。

```cpp
int i = 0;
int *p = &i;
decltype(*p) d = i; // int&
```

5. 如果变量名加上一对/多对括号，编译器将其作为表达式处理。变量是一种可以作为赋值语句左值的特殊表达式，所以 decltype 得到的永远是引用类型。



## 自定义数据类型

> 详见类和对象

### struct

1. 类内部定义的名字必须唯一，但是可以于类外定义的名字重复。
2. 类体右侧表示结束的花括号后面必须写一个分号，因为类体后面可以紧跟变量名以表示该类型对象的定义。
3. 一般来说，最好不要把对象的定义和类的定义放在一起。
4. 可以为数据成员提供一个类内初始值。只能使用花括号或者等于号，**不能使用圆括号**。

```cpp
struct Sales_data
{
    unsigned units_sold = 0; // 可以为数据成员提供一个类内初始值。
};
```





## 迭代器

1. 类似于指针类型，迭代器也提供了对对象的间接访问。
2. 有迭代器的类型同时拥有返回迭代器的成员，例如 .begin() 和 .end() 成员。其中 .begin() 成员负责返回指向第一个元素的迭代器；**.end() 成员负责返回指向尾元素的下一个位置的迭代器**，也就是说。该迭代器指示的是容器一个本不存在的尾后元素，仅为标记，无意义。如果容器为空，则 .begin() 和 .end() 返回同一个迭代器，尾后迭代器。**不能对 .end() 返回的迭代器作解引用**！
3. c++11 引入 .cbegin() 和 .cend() 函数来获取容器的常量迭代器。
4. 标准库定义的容器里，都有iterator和const_iterator，例如：

```cpp
#include <vector> 

std::vector<int>::iterator it;
```

5. **但凡是使用了迭代器的循环体，都不要向迭代器所属的容器添加元素**；可能会使迭代器失效。



### 运算符

1. 试图解引用一个非法迭代器或者尾后迭代器都是未定义的行为。

```cpp
// *, 返回迭代器iter所指元素的引用。
*iter;			
// ->, 解引用iter并获取该元素的名为mem的成员，等价于(*iter).mem
iter->mem;			
// ++, 令iter指向容器的下一个元素
++iter;				
// --, 令iter指向容器的上一个元素
--iter;				
// ==, != 判断两个迭代器是否相等(不相等)，如果两个迭代器指示的是同一个元素或者是同一个容器的尾后迭代器，则相等，反着，不相等。
iter1 == iter2;		
iter1 != iter2;
```



### example

```cpp
// 判断字符串是否为空
if (s.begin() != s.end())
{
    ;
}

// 利用++运算符指向下一个元素
// 遍历s的所有元素
for (auto it = s.begin(); it != s.end(); ++it)
{
    std::cout << *it << std::endl;
}

// 二分查找
auto beg = text.begin(), end = text.end();
auto min = text.begin + (end - beg) / 2;
while (mid != end && *mid != sought)
{
    if (sought < mid)
    {
        end = mid;
    }
    else
    {
        beg = mid + 1;
    }
    mid = beg + (end - beg) / 2;
}
```



## 数组



# 变量

1. 对象是指一块能存储数据并具有某种类型的内存空间，和变量类似。
2. 建议在第一次使用变量时再对其进行定义。
3. （函数体外变量）变量的声明（多次）和定义（一次）可分离（分离式编译），声明时需要加上 extern 关键字，且不要显示地初始化变量（**任何包含了显示初始化的声明就成了定义**）。

```cpp
extern int val;
```

4. 临时量对象就是当编译器需要一个控件来暂存表达式的求值结果临时创建的一个未命名对象。即临时量。



## 初始化

1. 指对象在创建时获得一个特定的值。
2. C++中，初始化和赋值是两个完全不同的操作。**==初始化是创建变量时赋予其一个初始值，而赋值的含义是把对象的当前值擦除，再以一个新值来替代==**。
3. 列表初始化：即 C++11 新增的花括号初始化，**当用于内置类型的变量时，如果存在丢失信息的风险，编译器会报错**。
4. 函数体外变量，即全局变量，未初始化时，默认用 0 进行初始化。
5. 每个类各自决定其初始化对象的方式，而且，是否允许不经过初始化就定义对象也由类自己决定，如果类允许这种行为，它将决定对象的初始值到底是什么。
6. 未初始化的内置类型变量含有一个不确定的值，会导致异常bug。**==每一个内置类型变量都应该被初始化==**。
7. 使用拷贝初始化时，只能提供一个初始值。
8. 如果提供的是一个类内初始值，则只能使用拷贝初始化或使用花括号的形式初始化。
9. 如果提供的是初始元素值的列表，则只能把初始值都放在花括号里进行列表初始化，而不能放在圆括号里。

```cpp
int val = 0;	// 拷贝初始化
int val = {0};
int val{0};
int val(0);

struct tmp
{
    int val = 0; // 类内初始值
};
```



## 作用域

1. 全局作用域
2. 块作用域
3. 当局部变量的标识符和全局变量的标识符一致时，优先使用局部变量。但如果函数有可能使用到某全局变量，则不宜再定义一个同名的局部变量。



## const

1. const对象一旦创建后其值就不能再改变，所以const对象必须初始化。
1. 只能在 const 类型的对象上执行不改变其内容的操作。
1. 默认状态下，const对象仅在文件内有效。（原因是编译器必须知道对象的初始值）
1. **当多个文件中出现同名的const变量时，其等同于在不同文件中分别定义了独立的变量**。
1. 如果想在一个文件中定义一个 const 变量，而多个文件声明使用的话，那么，只需要在声明以及定义时都添加关键字 extern 即可。
1. const 引用（参考变量 --- 引用部分）。
1. const 指针（参考变量 --- 指针部分 -- 11. const）。
1. 顶层 const 指的是对象是常量对象，对象不能被修改。
1. 底层 const 一般是指针才有，指向的对象不能被修改。



# constexpr 和常量表达式

1. 常量表达式是指值不会改变且在**编译过程就能得到计算结果的表达式**。
2. 字面值属于常量表达式。用常量表达式初始化的 const 对象也是常量表达式。
3. 允许将变量声明为 constexpr 类型以便由编译器来验证变量是否是一个常量表达式。
4. 声明为 constexpr 的变量一定是一个常量，而且必须用常量表达式初始化。
5. 自定义类不属于字面值类型。不能被定义为 constexpr。



# 头文件

1. 头文件通常包含那些只能被定义一次的实体，如类、const 和 constexpr 变量。
2. 头文件保护符：

```cpp
#ifndef 
#define
#endif
```

