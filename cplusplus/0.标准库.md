# 数据类型

## std::string

> 可变长的字符序列。标准库提供。

1. 字符串字面值不是 std::string 对象。

### init

```cpp
#include <string>

// init
std::string s1; 			// 空字符串
std::string s2(s1); 		// s2是s1的副本, 直接初始化
std::string s2 = s1; 		// 同上, 拷贝初始化
std::string s3("value"); 	// s3值为 "value"
std::string s3 = "value";	// 同上
std::string s4(n, c);		// 把s4初始化为由类型n个字符c组成的字符串
```



### 操作

```cpp
#include <string>

// operator
os << s; 			// 写入流, 返回os
is >> s;			// 读出流, 忽略开头的空白(空格符, 换行符, 制表符等), 直到读到下一次空白分隔结束, 返回is
getline(is, s);		// 从is中读取一行赋给s, 返回is, 读取直到遇到换行符为止, 会包含换行符, 但换行符不会存到 s 对象中, 而是被丢弃。
s.empty();			// 是否为空
s.size();			// 返回字符个数
s[n];				// 返回第n个字符的引用, n从0开始
s1 + s1;
s1 = s2;
s1 == s2;
s1 != s2;
// <, <=, >, >=
```



### 判断字符函数

```cpp
#include <cctype>

// 判断字符函数
std::isalnum(c);	// 当c为字母或数字时为真
std::isalpha(c);	// 当c为字母时为真
std::iscntrl(c);	// 当c为控制字符时为真
std::isdigit(c);	// 当c为数字时为真
std::isgraph(c);	// 当c不是空格但可打印时为真。
std::islower(c);	// 当c是小写字母时为真
std::isprint(c);	// 当c是可打印字符时为真（即c是空格或c具有可视形式）
std::ispunct(c);	// 当c是标点符号时为真（即c不是控制字符、数字、字母、可打印空白中的一种）
std::isspace(c);	// 当c是空白时为真（即c是空格、制表符、回车符、换行符、进纸符中的一种）
std::isupper(c);	// 当c是大写字母时为真
std::isxdigit(c);	// 当c是十六进制数字时为真
std::tolower(c);	// 如果c是大写字母,输出对应的小写字母；否则原样输出c
std::toupper(c);	// 如果c是小写字母,输出对应的大写字母；否则原样输出c
```



### 范围for语句

```cpp
#include <string>

for (auto ch : s) {
    ;
}
```



### 下标访问

> C++标准并不要求标准库检测下标是否合法。

```cpp
for (decltype(str.size()) i = 0; i < s.size(); i++) {
    
}
```



## std::vector

1. 实例化必须传入类型。
1. C++标准要求vector应该能在**运行时高效快速地**添加元素。
1. 不能通过下标来添加元素。
1. .push_back() 可能会使 vector对象的迭代器失效。



### init

```cpp
#include <vector>

using std::vector;

vector<T> v1;					// v1是一个空vector，它潜在的元素是T类型的，执行默认初始化
vector<T> v2(v1);				// v2中包含v1所有元素的副本
vector<T> v2 = v1;				// 等价于v2(v1), v2中包含v1所有元素的副本
vector<T> v3(n, val);			// v3包含了n个重复的元素, 每个元素的值都是val
vector<T> v4(n);				// v4包含了n个重复地执行值初始化的对象。内置类型会每个元素赋值为0，类则会执行默认初始化。

// 如果提供的是初始元素值的列表，则只能把初始值都放在花括号里进行列表初始化，而不能放在圆括号里。
vector<T> v5{a, b, c...};		// V5包含了初始值个数的元素，每个元素被赋予相应的初始值。
vector<T> v5 = {a, b, c...};	// 等价于v5{a, b, c...}
```



### 操作

```cpp
#include <vector>

using std::vector;

vector<T> v;

v.push_back(e); 	// 向v的尾部添加元素e

v.empty();			// v是否为空（不包含任何元素）

v.size();			// v中元素的个数

v[n];				// 返回第n个元素的引用，[0, v.size())

v1 = v2;			// 用v2中的元素拷贝替换v1中的元素

v1 = {a,b,c...};	// 用列表中的元素拷贝替换v1中的元素

v1 == v2;			// v1和v2相等当且仅当它们的元素数量相同且对应位置的元素值都相同
v2 != v2;
<, <=, >, >=		// 元素应该是支持比较运算符的。每个元素逐个比较
    
// 支持范围for语句
for (auto &i : v) {
 	;   
}
```



# 协程coroutines

> 标准：c++20

## base

1. **协程是能暂停执行以在之后恢复的函数**。
2. 协程是无栈的：它们通过返回到调用方暂停执行，并且恢复执行所需的数据与栈分离存储。
3. 这样就可以编写异步执行的顺序代码（例如不使用显式的回调来处理非阻塞输入/输出），还支持作用于惰性计算的无限序列上的算法及其他用途。



## 限制

1. 协程函数必须包含以上三个之中至少一个关键字
    1. **co_await**: 暂停执行, 直至恢复
    2. **co_yield**: 暂停执行并返回一个值。
    3. **co_return**: 用于完成执行并返回一个值

2. 不能使用变长实参, 普通 return 语句，或占位符返回类型(auto或概念)
3. constexpr 函数, consteval 函数、构造函数、析构函数以及 main 函数不能是协程

```cpp
// co_await: 暂停执行, 直至恢复
task<> tcp_echo_server() {
	char data[1024] = {0};
	while (true) {
		std::size_t n = co_await sock.async_read_some(buffer(data));
		co_await async_write(socket, buffer(data, n));
	}
}

// co_yield: 暂停执行并返回一个值
generator<unsigned int> iota(unsigned int n) {
	while (true) {
		co_yield n++;
	}
}

// co_return: 用于完成执行并返回一个值
lazy<int> f() {
	co_return 7;
}

// 假定 task 为某种协程任务类型
task<void> f() {
    // 不是协程，未定义行为
}
```



## 执行

**每个协程都与下列对象关联**：

1. 承诺对象，在协程内部操纵。协程通过此对象提交其结果或异常，
2. 协程句柄，在协程外部操纵。这是用于恢复协程执行或销毁协程帧的不带所有权句柄。
3. 协程状态，它是一个动态存储分配的内部对象，其包含：
    1. 承诺对象
    2. 各个形参（全部按值复制）
    3. 当前暂停点的某种表示，使得程序在恢复时知晓要从何处继续，销毁时知晓有哪些局部变量在作用域内
    4. 生存期跨过当前暂停点的局部变量和临时变量



### 开始执行

当协程开始执行时, 它进行下列操作:

1. 用 operator new 分配协程状态对象。
2. **将所有函数形参复制到协程状态中：以值传递的形参被移动或复制，按引用传递的形参保持为引用**（因此，如果在被指代对象的生存期结束后恢复协程，它有可能变成悬垂引用）

```cpp
// 形参会悬垂引用的例子

struct promise;

struct coroutine : std::coroutine_handle<promise> {
	using promise_type = ::promise;
};

struct promise {
	coroutine get_return_object() {
		return { coroutine::from_promise(*this) };
	}
	std::suspend_always initial_suspend() noexcept {
		return {};
	}
	std::suspend_always final_suspend() noexcept {
		return {};
	}
	void return_void() {}
	void unhandled_exception() {}
};

struct S {
	int i;
	coroutine f() {
		std::cout << i;
		co_return;
	}
};

void bad1() {
	coroutine h = S{0}.f();
	// S{0}被销毁
	h.resume(); // 协程恢复并执行 std::cout << i, 但实际i已被销毁
	h.destroy();
}

coroutine bad2() {
	S s{0};
	return s.f(); // 返回的协程不能被恢复执行，否则会导致释放后使用。
}

void bad3() {
	coroutine h = [i = 0] () -> coroutine { // 一个lambda，同时也是协程
		std::cout << i;
		co_return;
	} (); // 立即调用
	// lambda被销毁
	h.resume(); // 释放后使用了 lambda::i
	h.destroy();
}

void good() {
	coroutine h = [] (int i) -> coroutine {
		std::cout << i;
		co_return;
	} (0);
	// lambda被销毁
	h.resume(); // 没问题, i已经作为按值传递的形参被复制到协程帧中
	h.destroy();
}
```



3. 调用承诺对象的构造函数。如果承诺类型拥有接收所有协程形参的构造函数，那么以复制后的协程实参调用该构造函数。否则调用默认构造函数。
4. 调用 promise.get_return_object()，并将结果保存在局部变量中。该调用结果将在协程首次暂停时返回给调用方。至此并包含这个步骤为止，任何抛出的异常均传播回调用方，而非置于承诺中。
5. 调用 promise.initial_suspend(), 并 co_await 它的结果。典型的承诺类型Promise要么（对于惰性启动的协程）返回std::suspend_alawys, 要么（对于急切启动的协程）返回std::suspend_never.
6. 当 co_await promise.initial_suspend() 恢复时，开始协程体的执行



### 抵达暂停点

1. 将先前获得的返回对象返回给调用方/恢复方，如果需要就先隐式转换到协程的返回类型。



### 结束

#### co_return 

当协程抵达 co_return 语句时，它进行以下操作：

1. 对下列情形调用 promise.return_void()
    1. co_return;
    2. co_return expr；其中，expr 具有 void 类型

2. 对于 co_return expr；其中，expr具有非void类型时，调用 promise.return_value(expr);
3. 以创建顺序的逆序销毁所有具有自动存储期的变量。
4. 调用 promise.final_suspend() 并 co_await 它的结果。

```cpp
// 假定 task 为某种协程任务类型

task<void> g() {
    co_return;  // OK
}
```



#### 控制流结尾

1. 控制流协程的结尾，等价于co_return, 但如果在Promise的作用域中没有找到return_void的声明，那么行为是未定义的。
2. 函数体中没有任何一个定义关键词的函数不是协程，无论其返回类型为何，并且如果返回类型不是（可有cv限定的）void，那么控制流出它的结尾导致未定义行为。

```cpp
// 假定 task 为某种协程任务类型
 
task<void> h() {
    co_await g();
    // OK, 隐式 co_return;
}
```



#### 异常结束

如果协程因未捕获的异常结束，那么它进行下列操作：

1. 捕获异常并在处理块内调用 promise.unhandled_exception()
2. 调用 promise.final_suspend() 并 co_await 它的结果（例如，恢复某个继续或发布某个结果）。此时恢复协程是未定义行为。



### 协程状态销毁

经由 co_return 或未捕获异常而终止协程导致协程状态被销毁，或通过它的句柄销毁它时，进行以下操作： 

1. 调用承诺对象的析构函数。
2. 调用各个函数形参副本的析构函数。
3. 调用 operator delete 以释放协程状态所用的内存。
4. 转移执行回到调用方/恢复方。



## 动态分配

1. 协程状态通过**非数组形式 operator new** 动态分配。
2. 如果承诺类型 Promise 定义了类级别的替代函数，那么会使用它，否则会使用全局的 operator new。
3. 如果承诺类型 Promise 定义了接收额外形参的 operator new 的布置形式，且它们所匹配的实参列表中的第一实参是要求的大小（std::size_t 类型），而其余则是各个协程函数实参，那么将这些实参传递给 operator new（这使得能对协程使用前导分配器约定）
4. 以下情况下，可以优化掉对 operator new 的调用（即使使用了自定义分配器）：协程状态的生存期严格内嵌于调用方的生存期，且协程帧的大小在调用点已知
5. 此时协程状态嵌入调用方的栈帧（如果调用方是普通函数）或协程状态（如果调用方是协程）之中。
6. 如果分配失败，那么协程抛出 std::bad_alloc，除非承诺类型 Promise 类型定义了成员函数 Promise::get_return_object_on_allocation_failure()。
7. 如果定义了该成员函数，那么使用 operator new 的不抛出形式进行分配，而在分配失败时，协程会立即将从 Promise::get_return_object_on_allocation_failure() 获得的对象返回给调用方，例如：

```cpp
struct Coroutine::promise_type {
    /* ... */
 
    // 确保使用不抛出 operator-new
    static Coroutine get_return_object_on_allocation_failure() {
        std::cerr << __func__ << '\n';
        throw std::bad_alloc(); // 或者返回 Coroutine(nullptr);
    }
 
    // 自定义重载不抛出 new
    void* operator new(std::size_t n) noexcept {
        if (void* mem = std::malloc(n))
            return mem;
        return nullptr; // 分配失败
    }
};
```



## 承诺:

1. 编译器用 std::coroutine_traits 从协程的返回类型确定承诺类型 Promise。
2. 正式而言：
    1. 令 R 与 Args... 分别代表协程的返回类型与形参类型列表，
    2. 如果协程被定义为非静态成员函数，那么令 ClassT 代表协程所属的类，
    3. 如果协程被定义为非静态成员函数，那么令 cv 代表协程的函数声明的 cv 限定，

3. 以如下方式确定它的承诺类型 Promise：
    1. std::coroutine_traits<R, Args...>::promise_type，如果协程未被定义为隐式对象成员函数，
    2. std::coroutine_traits<R, cv ClassT&, Args...>::promise_type，如果协程被定义为非右值引用限定的隐式对象成员函数，
    3. std::coroutine_traits<R, cv ClassT&&, Args...>::promise_type，如果协程被定义为右值引用限定的隐式对象成员函数。

4. 例如：

| 如果定义协程为                      | 那么它的承诺类型 Promise 是                                  |
| ----------------------------------- | ------------------------------------------------------------ |
| `task<void> foo(int x)`;            | `std::coroutine_traits<task<void>, int>::promise_type`       |
| `task<void> Bar::foo(int x) const`; | `std::coroutine_traits<task<void>, const Bar&, int>::promise_type` |
| `task<void> Bar::foo(int x) &&`;    | `std::coroutine_traits<task<void>, Bar&&, int>::promise_type` |



## co_await

一元运算符 co_await 暂停协程并将控制返回给调用方。它的操作数是一个表达式，它

1. 要么具有定义了成员 operator co_await 的类类型，或者可以被传递给某个非成员 operator co_await，

2. 要么能以当前协程的 Promise::await_transform 转换到这种类类型。

     

### co_await 表达式

co_await 表达式只能在常规函数体（包括 lambda 表达式的函数体）里面的**潜在求值表达式中**出现，并且不能在以下位置出现：

1. 处理块中
2. 声明语句中，但可以在该声明语句的初始化式中出现
3. 初始化语句 的简单声明中（见 if、switch、for 以及范围 for），但可以在该初始化语句 的初始化式中出现，
4. 默认实参中
5. 具有静态或线程存储期的块作用域变量的初始化式中。



### 将表达式 转换成可等待体

首先，以下列方式将表达式 转换成可等待体：

1. 如果表达式 由初始暂停点、最终暂停点或 yield 表达式所产生，那么可等待体是表达式 本身。
2. 否则，如果当前协程的承诺类型 Promise 拥有成员函数 await_transform，那么可等待体是 promise.await_transform(表达式)。
3. 否则，可等待体是表达式 本身。



### 获得等待器对象

然后以下列方式获得等待器对象：

1. 如果针对 operator co_await 的重载决议给出单个最佳重载，那么等待器是该调用的结果：
    1. 对于成员重载为 awaitable.operator co_await();，
    2. 对于非成员重载为 operator co_await(static_cast<Awaitable&&>(awaitable));

2. 否则，如果重载决议找不到 operator co_await，那么等待器是可等待体本身。
3. 否则，如果重载决议有歧义，那么程序非良构。
4. 如果上述表达式为纯右值，那么等待器对象是从它实质化的临时量。否则，如果上述表达式为泛左值，那么等待器对象是它所指代的对象。



### 调用awaiter.await_ready()

然后，调用 awaiter.await_ready()（这是当已知结果就绪或可以同步完成时，用以避免暂停开销的快捷方式）。

如果它的结果按语境转换到 bool 的结果是 false，那么：

1. 暂停协程（以各局部变量和当前暂停点填充其协程状态）。
2. 调用 awaiter.await_suspend(handle)，其中 handle 是表示当前协程的协程把柄。这个函数内部可以通过这个把柄观察暂停协程的状态，而且此函数负责调度它以在某个执行器上恢复，或将其销毁（并返回 false 当做调度）
    1. 如果 await_suspend 返回 void，那么立即将控制返回给当前协程的调用方/恢复方（此协程保持暂停），否则
    2. 如果 await_suspend 返回 bool，那么：
        1. 值为 true 时将控制返回给当前协程的调用方/恢复方
        2. 值为 false 时恢复当前协程。

    3. 如果 await_suspend 返回某个其他协程的协程把柄，那么（通过调用 handle.resume()）恢复该把柄（注意这可以连锁进行，并最终导致当前协程恢复）。
    4. 如果 await_suspend 抛出异常，那么捕捉该异常，恢复协程，并立即重抛异常。

3. 最后，当协程重新获得控制时（无论协程是否被暂停过），调用 awaiter.await_resume()，它的结果就是整个 co_await expr 表达式的结果。

### 暂停后再恢复

如果协程在 co_await 表达式中暂停而在后来恢复，那么恢复点处于紧接对 awaiter.await_resume() 的调用之前。

1. 注意，因为协程在进入 awaiter.await_suspend() 前已经完全暂停，所以该函数可以自由地在线程间转移协程把柄而无需额外同步。
2. 例如，可以将它放入回调，将它调度成在异步输入/输出操作完成时在线程池上运行等。此时因为当前协程可能已被恢复，从而执行了等待器的析构函数，同时由于 await_suspend() 在当前线程上持续执行， await_suspend() 应该把 *this 当作已被销毁并且在把柄被发布到其他线程后不再访问它。
3. 注意：等待器对象是协程状态的一部分（作为生存期跨过暂停点的临时量），并且在 co_await 表达式结束前销毁。可以用它维护某些异步输入/输出 API 所要求的每操作内状态，而无需用到额外的堆分配。

```cpp
#include <coroutine>
#include <iostream>
#include <stdexcept>
#include <thread>
 
auto switch_to_new_thread(std::jthread& out) {
    struct awaitable {
        std::jthread* p_out;
        bool await_ready() { return false; }
        void await_suspend(std::coroutine_handle<> h) {
            std::jthread& out = *p_out;
            if (out.joinable()) {
                throw std::runtime_error("jthread 输出参数非空");
            }
            out = std::jthread([h] { h.resume(); });
            // 潜在的未定义行为：访问潜在被销毁的 *this
            // std::cout << "新线程 ID：" << p_out->get_id() << '\n';
            std::cout << "新线程 ID：" << out.get_id() << '\n'; // 这样没问题
        }
        void await_resume() {}
    };
    return awaitable{&out};
}
 
struct task {
    struct promise_type {
        task get_return_object() { return {}; }
        std::suspend_never initial_suspend() { return {}; }
        std::suspend_never final_suspend() noexcept { return {}; }
        void return_void() {}
        void unhandled_exception() {}
    };
};
 
task resuming_on_new_thread(std::jthread& out) {
    std::cout << "协程开始，线程 ID：" << std::this_thread::get_id() << '\n';
    co_await switch_to_new_thread(out);
    // 等待器在此销毁
    std::cout << "协程恢复，线程 ID：" << std::this_thread::get_id() << '\n';
}
 
int main() {
    std::jthread out;
    resuming_on_new_thread(out);
}
```



## co_yield

1. `co_yield` 表达式向调用方返回一个值并暂停当前协程：它是可恢复生成器函数的常用构建块。
2. 等价于：

```cpp
co_await promise.yield_value(表达式)
```

3. 典型的生成器的 `yield_value` 会将其实参存储（复制/移动或仅存储它的地址，因为实参的生存期跨过 `co_await` 内的暂停点）到生成器对象中并返回 `std::suspend_always`，将控制转移给调用方/恢复方。

```cpp
#include <coroutine>
#include <cstdint>
#include <exception>
#include <iostream>
 
template<typename T>
struct Generator {
    // 类名 'Generator' 只是我们的选择，使用协程魔法不依赖它。
    // 编译器通过关键词 'co_yield' 的存在识别协程。
    // 你可以使用 'MyGenerator'（或者任何别的名字）作为替代，只要在类中包括了
    // 拥有 'MyGenerator get_return_object()' 方法的嵌套 struct promise_type。
    // （注意：在重命名时，你还需要调整构造函数/析构函数的名字。）
 
    struct promise_type;
    using handle_type = std::coroutine_handle<promise_type>;
 
    struct promise_type { // 必要
        T value_;
        std::exception_ptr exception_;
 
        Generator get_return_object() {
            return Generator(handle_type::from_promise(*this));
        }
        std::suspend_always initial_suspend() { return {}; }
        std::suspend_always final_suspend() noexcept { return {}; }
        void unhandled_exception() { exception_ = std::current_exception(); } // 保存异常
 
        template <std::convertible_to<T> From> // C++20 概念
        std::suspend_always yield_value(From&& from) {
            value_ = std::forward<From>(from); // 在承诺中缓存结果
            return {};
        }
        void return_void() {}
    };
 
    handle_type h_;
 
    Generator(handle_type h) : h_(h) {}
    ~Generator() { h_.destroy(); }
    explicit operator bool() {
        fill(); // 获知协程是结束了还是仍能通过 C++ getter（下文的 operator()）
                // 获得下一个生成值的唯一可靠方式，是执行/恢复协程到下一个 co_yield 节点
                // （或让执行流抵达结尾）。
                // 我们在承诺中存储/缓存了执行结果，使得 getter（下文的 operator()）
                // 可以获得这一结果而不执行协程。
        return !h_.done();
    }
    T operator()() {
        fill();
        full_ = false;// 我们将移动走先前缓存的结果来重新置空承诺
        return std::move(h_.promise().value_);
    }
 
private:
    bool full_ = false;
 
    void fill() {
        if (!full_) {
            h_();
            if (h_.promise().exception_)
                std::rethrow_exception(h_.promise().exception_);
            // 在调用上下文中传播协程异常
 
            full_ = true;
        }
    }
};
 
Generator<uint64_t>
fibonacci_sequence(unsigned n) {
    if (n == 0)
        co_return;
 
    if (n > 94)
        throw std::runtime_error("斐波那契序列过大，元素将会溢出。");
 
    co_yield 0;
 
    if (n == 1)
        co_return;
 
    co_yield 1;
 
    if (n == 2)
        co_return;
 
    uint64_t a = 0;
    uint64_t b = 1;
 
    for (unsigned i = 2; i < n; i++)
    {
        uint64_t s = a + b;
        co_yield s;
        a = b;
        b = s;
    }
}
 
int main() {
    try {
        auto gen = fibonacci_sequence(10); // 最大值94，避免 uint64_t 溢出
 
        for (int j = 0; gen; j++)
            std::cout << "fib(" << j << ")=" << gen() << '\n';
    }
    catch (const std::exception& ex) {
        std::cerr << "发生了异常：" << ex.what() << '\n';
    }
    catch (...) {
        std::cerr << "未知异常。\n";
    }
}
```



# 线程

## 线程池

ThreadPool.h

```c++
#ifndef INC_THREADPOOL_H
#define INC_THREADPOOL_H 1

#include <thread>
#include <functional>

namespace ThreadPool {
	int Init(const int min_threads_nums, const int max_threads_nums);
	int Destory();
	int AddTask(std::function<void()> &&task);

	template <typename Func, typename...Args>
	inline int AddTask(Func &&func, Args&&...args) {
        auto task = std::bind(std::forward<Func>(func), std::forward<Args>(args)...);
        return AddTask(std::function<void()>(std::move(task)));
	}
}
#endif
```



```cpp
#include <map>
#include <mutex>
#include <queue>
#include <atomic>
#include <condition_variable>

#include "ThreadPool.h"

class CThreadPoolMng {
private:
	const int m_min_threads;
	const int m_max_threads;
	std::thread *m_manager;
	std::map<std::thread::id, std::thread> m_workers;
	std::vector<std::thread::id> m_ids;
	std::atomic<bool> m_stop;
	std::atomic<int> m_cur_threads;
	std::atomic<int> m_idle_threads;
	std::atomic<int> m_exit_nums;
	std::queue<std::function<void()>> m_tasks;
	std::mutex m_ids_mtx;
	std::mutex m_queue_mtx;
	std::condition_variable m_conditions;
private:
	void worker_func() {
		while (m_stop.load() != true || m_tasks.empty() != true) {
			std::function<void()> task = nullptr;
			{
				std::unique_lock<std::mutex> lock(m_queue_mtx);
				while (m_tasks.empty()) {
					m_conditions.wait(lock);
					if (m_exit_nums.load() > 0) {
						std::lock_guard<std::mutex> lck(m_ids_mtx);
						if (m_exit_nums.load() <= 0) {
							continue;
						}
						m_exit_nums--;
						m_ids.emplace_back(std::this_thread::get_id());
						std::printf("destory thread...\n");
						m_idle_threads--;
						return;
					}
					if (m_tasks.empty() && m_stop.load()) {
						std::printf("exit thread...\n");
						m_idle_threads--;
						return;
					}
				}

				if (m_tasks.empty() != true) {
					task = std::move(m_tasks.front());
					m_tasks.pop();
				}
			}
			if (task) {
				m_idle_threads--;
				task();
				m_idle_threads++;
			}
		}
	}
	void manager_func() {
		// 创建工作线程
		for (int i = 0; i < m_min_threads; i++) {
			std::thread t(&CThreadPoolMng::worker_func, this);
			m_workers.insert(std::make_pair(t.get_id(), std::move(t)));
			m_cur_threads++;
			m_idle_threads++;
		}
		while (m_stop.load() != true || m_tasks.empty() != true) {
			if (m_min_threads == m_max_threads) {
				std::this_thread::sleep_for(std::chrono::seconds(10));
				continue;
			}
			const int idle = m_idle_threads.load();													// 闲置线程
			const int current = m_cur_threads.load();												// 当前线程
			// 任务过多
			if (0 == idle && current < m_max_threads && m_tasks.empty() != true) {
				std::thread t(&CThreadPoolMng::worker_func, this);
				m_workers.insert(std::make_pair(t.get_id(), std::move(t)));
				std::printf("add thread...\n");
				m_cur_threads++;
				m_idle_threads++;
				continue;
			}
			// 线程过多
			const int delnum = ((current - m_min_threads) >= 5 ? 5 : (current - m_min_threads));	// 当线程池数过多时, 删除的线程数
			const bool more_cond = (idle > current / 2 && current - delnum >= m_min_threads);		// 线程是否过多判断条件
			if (delnum <= 0 || more_cond != true) {
				std::this_thread::sleep_for(std::chrono::seconds(1));
				continue;
			}
			m_exit_nums += delnum;
			m_conditions.notify_all();
			std::this_thread::sleep_for(std::chrono::milliseconds(10));
			std::lock_guard<std::mutex> lck(m_ids_mtx);
			for (const auto &id : m_ids) {
				auto it = m_workers.find(id);
				if (m_workers.end() == it) {
					continue;
				}
				if (it->second.joinable()) {
					it->second.join();
				}
				m_workers.erase(it);
				m_cur_threads--;
			}
			m_ids.clear();
			std::this_thread::sleep_for(std::chrono::seconds(10));
			continue;
		}

		// 销毁工作线程
		for (auto &it : m_workers) {
			std::thread &t = it.second;
			if (t.joinable()) {
				t.join();
			}
		}
	}
public:
	CThreadPoolMng(const int min_threads_nums, const int max_threads_nums) : m_min_threads(min_threads_nums), m_max_threads(max_threads_nums) {
		m_stop = false;
		m_idle_threads = m_cur_threads = m_exit_nums = 0;
		m_manager = new std::thread(&CThreadPoolMng::manager_func, this);
	}
	~CThreadPoolMng() {
		m_stop = true;
		m_conditions.notify_all();
		if (m_manager->joinable()) {
			m_manager->join();
		}
		delete m_manager;
	}
	void add_task(std::function<void()> &&task) {
		if (m_stop.load() == true) {
			return;
		}
		else {
			std::lock_guard<std::mutex> lock(m_queue_mtx);
			m_tasks.emplace(std::move(task));
		}
		m_conditions.notify_all();
	}
};

static std::mutex s_threadinit_lock;
static CThreadPoolMng *s_threadpoolmng = nullptr;

int ThreadPool::Init(const int min_threads_nums, const int max_threads_nums) {
	if (min_threads_nums < 1 || max_threads_nums < min_threads_nums) {
		return -1;
	}
	if (s_threadpoolmng != nullptr) {
		return -2;
	}
	std::lock_guard<std::mutex> lock(s_threadinit_lock);
	if (s_threadpoolmng != nullptr) {
		return -3;
	}
	s_threadpoolmng = new CThreadPoolMng(min_threads_nums, max_threads_nums);
	return 0;
}

int ThreadPool::Destory() {
	if (nullptr == s_threadpoolmng) {
		return -1;
	}
	std::lock_guard<std::mutex> lock(s_threadinit_lock);
	if (s_threadpoolmng != nullptr) {
		return -2;
	}
	delete s_threadpoolmng;
	s_threadpoolmng = nullptr;
	return 0;
}

int ThreadPool::AddTask(std::function<void()> &&task) {
	if (nullptr == s_threadpoolmng) {
		return -1;
	}
	s_threadpoolmng->add_task(std::move(task));
	return 0;
}
```





```cpp
#include <thread>
#include <mutex>
#include <vector>
#include <queue>
#include <atomic>
#include <functional>
#include <condition_variable>
#include <map>
#include <future>

// 线程池类
class ThreadPool
{
public:
    ThreadPool(int min = 4, int max = std::thread::hardware_concurrency());
    ~ThreadPool();
    void addTask(std::function<void()> f);

private:
    void manager();
    void worker();
private:
    std::thread* m_manager;
    std::map<std::thread::id, std::thread> m_workers; 
    std::vector<std::thread::id> m_ids; 
    int m_minThreads;
    int m_maxThreads; 
    std::atomic<bool> m_stop; 
    std::atomic<int> m_curThreads;
    std::atomic<int> m_idleThreads;
    std::atomic<int> m_exitNumber; 
    std::queue<std::function<void()>> m_tasks;
    std::mutex m_idsMutex; 
    std::mutex m_queueMutex;
    std::condition_variable m_condition;
};

#include <iostream>

ThreadPool::ThreadPool(int min, int max) : m_maxThreads(max),
m_minThreads(min), m_stop(false), m_exitNumber(0)
{
    //m_idleThreads = m_curThreads = max / 2;
    m_idleThreads = m_curThreads = min;
    std::cout << "线程数量: " << m_curThreads << std::endl;
    m_manager = new std::thread(&ThreadPool::manager, this);
    for (int i = 0; i < m_curThreads; ++i)
    {
        std::thread t(&ThreadPool::worker, this);
        m_workers.insert(std::make_pair(t.get_id(), move(t)));
    }
}

ThreadPool::~ThreadPool()
{
    m_stop = true;
    m_condition.notify_all();
    for (auto& it : m_workers)
    {
        std::thread& t = it.second;
        if (t.joinable())
        {
            std::cout << "******** 线程 " << t.get_id() << " 将要退出了..." << std::endl;
            t.join();
        }
    }
    if (m_manager->joinable())
    {
        m_manager->join();
    }
    delete m_manager;
}

void ThreadPool::addTask(std::function<void()> f)
{
    {
        std::lock_guard<std::mutex> locker(m_queueMutex);
        m_tasks.emplace(f);
    }
    m_condition.notify_one();
}

void ThreadPool::manager()
{
    while (!m_stop.load())
    {
        std::this_thread::sleep_for(std::chrono::seconds(2));
        int idle = m_idleThreads.load();
        int current = m_curThreads.load();
        if (idle > current / 2 && current > m_minThreads)
        {
            m_exitNumber.store(2);
            m_condition.notify_all();
            std::unique_lock<std::mutex> lck(m_idsMutex);
            for (const auto& id : m_ids)
            {
                auto it = m_workers.find(id);
                if (it != m_workers.end())
                {
                    std::cout << "############## 线程 " << (*it).first << "被销毁了...." << std::endl;
                    (*it).second.join();
                    m_workers.erase(it);
                }
            }
            m_ids.clear();
        }
        else if (idle == 0 && current < m_maxThreads)
        {
            std::thread t(&ThreadPool::worker, this);
            std::cout << "+++++++++++++++ 添加了一个线程, id: " << t.get_id() << std::endl;
            m_workers.insert(make_pair(t.get_id(), move(t)));
            m_curThreads++;
            m_idleThreads++;
        }
    }
}

void ThreadPool::worker()
{
    while (!m_stop.load())
    {
        std::function<void()> task = nullptr;
        {
            std::unique_lock<std::mutex> locker(m_queueMutex);
            while (!m_stop && m_tasks.empty())
            {
                m_condition.wait(locker);
                if (m_exitNumber.load() > 0)
                {
                    std::cout << "----------------- 线程任务结束, ID: " << std::this_thread::get_id() << std::endl;
                    m_exitNumber--;
                    m_curThreads--;
                    std::unique_lock<std::mutex> lck(m_idsMutex);
                    m_ids.emplace_back(std::this_thread::get_id());
                    return;
                }
            }

            if (!m_tasks.empty())
            {
                std::cout << "取出一个任务..." << std::endl;
                task = move(m_tasks.front());
                m_tasks.pop();
            }
        }

        if (task)
        {
            m_idleThreads--;
            task();
            m_idleThreads++;
        }
    }
}

void calc(int x, int y)
{
    int res = x + y;
    std::cout << "res = " << res << std::endl;
    std::this_thread::sleep_for(std::chrono::seconds(2));
}

int main()
{
    ThreadPool pool(4);
    for (int i = 0; i < 10; ++i)
    {
        auto func = std::bind(calc, i, i * 2);
        pool.addTask(func);
    }
    getchar();
    return 0;
}
```

