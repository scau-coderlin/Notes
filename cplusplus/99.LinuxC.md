# I/O

> APUE --- 第三章 文件I/O，第五章 标准I/O库，第十四章 高级IO

1. 标准IO是对系统IO的抽象。
2. 在能实现相同功能时，优先使用stdio。
3. stdio移植性好，且合并系统调用，且合并系统调用有一个buf-cache机制，加快了读写效率。
4. 在不更改默认环境情况下，一个进程默认打开三个流，标准输入、输出和错误。
5. 查看/修改可打开的最大文件数

```sh
# 查看
ulimit -n

# 修改
ulimit -n 65536 # 作用于当前终端
```



## 取消标准输入大小限制

标准输入限制输入字符个数大小为4095个，以下命令可解除该限制：

```sh
# linux
stty -icanon
```



## C标准I/O库

### fopen

> man fopen

1. 谁打开，谁关闭。

```c
#include <stdio>

FILE *fopen(const char *path, const char *mode);
```



**参数**：

- path: 文件路径，可以是相对路径，也可以是绝对路径。

- mode:

	以以下字符串之一为开始的字符串：

	- `r` ：只读，文件必须存在，流被定位到文件的开始。
	- `r+`：读写，文件必须存在，流被定位到文件的开始。
	- `w`：只写，文件不存在时将被创建，文件存在时长度被截断为零，流被定位到文件的开始。
	- `w+`：读写，文件不存在时将被创建，文件存在时长度被截断为零，流被定位到文件的开始。
	- `a`：追加，文件不存在时将被创建，流被定位到文件的末尾进行追加（写）。
	- `a+`：读或追加，文件不存在时将被创建，读文件的初始位置是文件的开始，但是输出总是被追加到文件的末尾。
	- `b`：也可以包含 ` b` 作为最后一个字符，或者插入到上面提到的任何双字符的两个字符之间，用于读取二进制文件；这个参数在遵循 `POSIX` 的系统（类 `UNIX`）中，将被忽略。



**返回值**：

- 成功：返回一个指向堆内存的指针。
- 失败：返回空指针以及设置 `errno`。



**文件权限**：

1. 任何新建的文件将具有模式：

```shell
(S_IPUSR | S_IWUSR | S_IWGRP | S_IROTH | S_IWOTH) & (~umask)

# 即 0666 & (~umask) # 两个八进制数按位异或
```



2. umask：可以使用 uamsk 命令查看 umask 值，该值是为了赋值产生权限过松的文件。



### fclose

> 关闭流

1. 将流与其底层关联的文件或功能集合断开。
2. 如果流曾用作输出，任何缓冲的数据都将首先被写入，使用 `fflush`。
3. 仅仅刷新用户空间的由C库提供的缓冲，要保证数据被物理地存储到磁盘上，必须也刷新内核缓冲，例如使用 `sync` / `fsync`。

```c
#include <stdio.h>

int fclose(FILE *stream);
```



**返回值**：

成功：0

失败：`EOF`，且设置errno值。



# 文件系统

> APUE --- 第四章 文件和目录，第六章 系统数据文件和信息，第七章 进程环境



# 并发

> 多进程（信号）、多线程
>
> APUE --- 第八章 进程控制，第十章 信号，第十一章 线程



# IPC

> 进程间通信
>
> APUE --- 第八章 进程控制，第十三章 守护进程，第十五章 进程间通信，第十六章 网络IPC：套接字 



# othre

getpwuid

 localtime



# 程序信息

## 获取程序架构

```cpp
#include <unistd.h>
#include <sys/stat.h>
#include <sys/types.h>
#include <elf.h>

int GetExecMessage() {
    Elf64_Ehdr header;
    int fd = open(execname, O_RDONLY);
    read(fd, &header, sizeof(header));
    close(fd);
    
    // 检查ELF类型
	if (header.e_ident[EI_MAG0] != ELFMAG0 || header.e_ident[EI_MAG1] != ELFMAG1 || header.e_ident[EI_MAG2] != ELFMAG2 || header.e_ident[EI_MAG3] != ELFMAG3) {
		printf("in %s::%d:: header.e_ident[EI_MAG] err.\n", __func__, __LINE__);
		return -3;
	}

	// 检查字节序
	if (header.e_ident[EI_DATA] != ELFDATA2LSB && header.e_ident[EI_DATA] != ELFDATA2MSB) {
		printf("in %s::%d:: header.e_ident[EI_DATA] err.\n", __func__, __LINE__);
		return -4;
	}

	// 检查位数
	if (header.e_ident[EI_CLASS] != ELFCLASS64) {
		printf("in %s::%d:: header.e_ident[EI_CLASS] err.\n", __func__, __LINE__);
		return -5;
	}

#if defined(__x86_64__)
	const int machine = EM_X86_64;
#elif defined(__aarch64__)
	const int machine = EM_AARCH64;
#elif defined(__arm__)
	const int machine = EM_ARM;
#else
#error "Unsupported architecture"
#endif
	if (header.e_machine != machine) {
		switch (header.e_machine) {
		case EM_X86_64:
			printf("in %s::%d:: header.e_machine is __x86_64__, err.\n", __func__, __LINE__);
			break;
		case EM_ARM:
			printf("in %s::%d:: header.e_machine is EM_ARM, err.\n", __func__, __LINE__);
			break;
		case EM_AARCH64:
			printf("in %s::%d:: header.e_machine is EM_AARCH64, err.\n", __func__, __LINE__);
			break;
		default:
			printf("in %s::%d:: header.e_machine is unknown, err.\n", __func__, __LINE__);
			break;
		}
		return -6;
	}
	return 0;
}
```



# 文件操作

## 读取.tar.gz文件

> 使用zlib库进行处理

```cpp
#include <zlib.h>
int main() {
    gzFile file = gzopen(filename, "rb");
    gzread(file, buf, sizeof(buf));
    gzseek(file, size, SEEK_CUR);
    gzclose(file);
}
```





# 目录操作

## struct dirent

```cpp
struct dirent
  {
#ifndef __USE_FILE_OFFSET64
    __ino_t d_ino;
    __off_t d_off;
#else
    __ino64_t d_ino;
    __off64_t d_off;
#endif
    unsigned short int d_reclen;
    unsigned char d_type;		/* 文件类型 */
    char d_name[256];           /* We must not include limits.h! */
  };

#ifdef __USE_LARGEFILE64
struct dirent64
  {
    __ino64_t d_ino;
    __off64_t d_off;
    unsigned short int d_reclen;
    unsigned char d_type;
    char d_name[256];           /* We must not include limits.h! */
  };

/*
d_type： 文件类型
	DT_UNKNOWN: 未知
	DT_FIFO:	管道
	DT_CHR:		目录
	DT_BLK:		块设备
	DT_REG:		常规文件
	DT_LNK:		符号链接
	DT_SOCK:	套接字
	DT_WHT:		白皮书
*/
```



## opendir 打开目录

```c++
#include <dirent.h>
#include <sys/stat.h> // for stat()
#include <sys/types.h> // for opendir(), readdir(), closedir()

DIR *dir = opendir(path);
```



## closedir 关闭目录

```cpp
#include <dirent.h>
#include <sys/stat.h> // for stat()
#include <sys/types.h> // for opendir(), readdir(), closedir()

closedir (dir);
```



## readdir 读取目录

```cpp
#include <dirent.h>
#include <sys/stat.h> // for stat()
#include <sys/types.h> // for opendir(), readdir(), closedir()

for (struct dirent* de = readdir(dir); de != NULL; de = readdir(dir))
{
    
}
```



# 操作 /proc/pid/

1. 原理是，每一个进程在 /proc 目录下都有一个文件，命名为 pid。



## 获取某个进程的pid

```cpp
#include <string>
#include <iostream>

#include <errno.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <dirent.h>
#include <sys/time.h>
#include <sys/stat.h> // for stat()
#include <sys/types.h> // for opendir(), readdir(), closedir()

int UnionPgrep(const char *procname)
{
	const char PROC_DIRECTORY[] = "/proc/";

	int pid = -1;
	DIR* dir_proc = opendir(PROC_DIRECTORY) ;
	if (NULL == dir_proc)
	{
		printf("in %s::%d:: opendir for [%s] failed, errno = [%d][%s].\n", __func__, __LINE__, PROC_DIRECTORY, errno, strerror(errno));
		return -2;
	}

	char proc_path[128] = {0};
	char read_procname[512] = {0};
	for (struct dirent* de = readdir(dir_proc); de != NULL; de = readdir(dir_proc))
	{
		if (DT_DIR != de->d_type)
		{
			continue;
		}

		if (UnionIsDigitStr(de->d_name) == 0)
		{
			continue;
		}

		memset(proc_path, 0, sizeof(proc_path));
		strcpy(proc_path, PROC_DIRECTORY);
		strcat(proc_path, de->d_name);
		strcat(proc_path, "/cmdline");
		FILE *fp = fopen(proc_path, "rt");
		if (NULL == fp)
		{
			printf("in %s::%d:: fopen for [%s] failed, errno = [%d][%s].\n", __func__, __LINE__, proc_path, errno, strerror(errno));
			continue;
		}

		memset(read_procname, 0, sizeof(read_procname));
		fscanf(fp, "%s", read_procname);
		fclose(fp);
		fp = NULL;

		if (0x00 == read_procname[0])
		{
			continue;
		}

		char* ptr = strrchr(read_procname, '/');
		if (ptr != NULL)
		{
			ptr++;
		}
		else
		{
			ptr = read_procname;
		}
		
		if (strcmp(procname, ptr) == 0)
		{
			pid = atoi(de->d_name);
			break;
		}
	}
	closedir(dir_proc);
    return pid;
}
```



## 记录所有进程所使用的内存

```sh
# 某个进程
ps -o rss,vsz `ps -ef|grep unionHsmSvr|grep -v grep|awk '{print $2}'`
```



```cpp
#include <string>
#include <iostream>

#include <errno.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <dirent.h>
#include <sys/time.h>
#include <sys/stat.h> // for stat()
#include <sys/types.h> // for opendir(), readdir(), closedir()

#define LOG_MAX_SIZE 10 * 1024 * 1024
#define LOG_PATH "./mem.log"

class GuardCFile
{
private:
	FILE* &m_fp;
public:
	GuardCFile(FILE* &fp) : m_fp(fp) {}
	~GuardCFile()
	{
		if (m_fp != NULL)
		{
			fflush(m_fp);
			fclose(m_fp);
			m_fp = NULL;
		}
	}
};

class GuardLinuxDir
{
private:
	DIR* &m_dir;
public:
	GuardLinuxDir(DIR* &dir) : m_dir(dir) {}
	~GuardLinuxDir()
	{
		if (m_dir != NULL)
		{
			closedir(m_dir);
			m_dir = NULL;
		}
	}
};

//是不是数字
int UnionIsDigitStr(const char *str)
{
	const int length = strlen(str);
	for (int i = 0; i < length; i++)
	{
		if (isdigit(str[i]) == 0)
		{
			return 0;
		}
	}
	return 1;
}

int UnionGetAscSystemDateTimeWithMillsec(char *datetime)
{
	struct tm rtm;
	memset(&rtm, 0, sizeof(rtm));
	struct timeval tm;
	memset(&tm, 0, sizeof(tm));
	gettimeofday(&tm, NULL);
	const struct tm *tmptm = (struct tm*)localtime_r(&tm.tv_sec, &rtm);
	const int tmpyear = ((tmptm->tm_year > 90) ? (1900 + tmptm->tm_year % 1900) : 2000 + tmptm->tm_year);
	sprintf(datetime, "%04d-%02d-%02d %02d:%02d:%02d %ld.%ld", tmpyear, tmptm->tm_mon+1, tmptm->tm_mday, tmptm->tm_hour, tmptm->tm_min, tmptm->tm_sec, tm.tv_usec / 1000, tm.tv_usec % 1000);
	return 0;
}

int UnionGetProcInfoByStatus(const int pid, char *name, const int namesize, int *vmsize, int *vmrss) {
	if (pid < 0 || NULL == name || namesize <= 0 || NULL == vmsize || NULL == vmrss) {
		return -1;
	}
	const char Name[] = "Name";
	const int NameLen = strlen(Name);

	const char VmSize[] = "VmSize";
	const int VmSizeLen = strlen(VmSize);

	const char VmRSS[] = "VmRSS";
	const int VmRSSLen = strlen(VmRSS);

	char path[128] = {0};
	snprintf(path, sizeof(path), "/proc/%d/status", pid);

	FILE *fp = fopen(path, "r");
	GuardCFile gurad_fp(fp);
	if (NULL == fp) {
		printf("fopen() for [%s] failed, errno = [%d][%s].\n", path, errno, strerror(errno));
		return -2;
	}

	char buffer[256] = {0};
	memset(buffer, 0, sizeof(buffer));
	while (fgets(buffer, sizeof(buffer), fp) != NULL)
	{
		if (memcmp(buffer, Name, NameLen) == 0)
		{
			if (name != NULL && namesize > 0)
			{
				memset(name, 0, namesize);
				sscanf(buffer, "%*s %s", name);
			}
		}

		// ps -o rss,vsz `ps -ef | grep program_name | grep -v grep | awk '{print $2}'`
		if (memcmp(buffer, VmSize, VmSizeLen) == 0) // VSZ
		{
			if (vmsize != NULL)
			{
				*vmsize = 0;
				sscanf(buffer, "%*s %d", vmsize);
			}
		}

		if (memcmp(buffer, VmRSS, VmRSSLen) == 0) // RSS
		{
			if (vmrss != NULL)
			{
				*vmrss = 0;
				sscanf(buffer, "%*s %d", vmrss);
			}
		}
		memset(buffer, 0, sizeof(buffer));
	}

	return 0;
}

void UnionGetProcNameByCmdline(const int pid, char *name, const int namesize) {
	if (pid < 0) {
		return;
	}
	char path[128] = {0};
	snprintf(path, sizeof(path), "/proc/%d/cmdline", pid);
	FILE *fp = fopen(path, "r");
	GuardCFile gurad_fp(fp);
	if (NULL == fp) {
		printf("fopen() for [%s] failed, errno = [%d][%s].\n", path, errno, strerror(errno));
		return;
	}

	char buffer[256] = {0};
	fscanf(fp, "%s", buffer);

	if (0x00 == buffer[0]) {
		return;
	}
	char* ptr = strrchr(buffer, '/');
	if (ptr != NULL) {
		ptr++;
	}
	else {
		ptr = buffer;
	}

	if (name != NULL && namesize > 0) {
		memset(name, 0, namesize);
		strncpy(name, ptr, namesize);
	}
}

int UnionGetAllProcUseMem(const char *specified_procname)
{
	const char PROC_DIRECTORY[] = "/proc/";

	DIR* dir_proc = opendir(PROC_DIRECTORY);
	GuardLinuxDir guard_dir(dir_proc);
	if (NULL == dir_proc) {
		printf("opendir() for [%s] failed, errno = [%d][%s].\n", PROC_DIRECTORY, errno, strerror(errno));
		return -2;
	}

	FILE *log = fopen(LOG_PATH, "ab");
	GuardCFile gurad_log(log);
	if (NULL == log) {
		printf("fopen() for [%s] failed, errno = [%d][%s].\n", LOG_PATH, errno, strerror(errno));
		return -3;
	}

	if (ftell(log) > LOG_MAX_SIZE) {
		fclose(log);
		log = NULL;
		char lognamebak[256] = {0};
		snprintf(lognamebak, sizeof(lognamebak), "%s.bak", LOG_PATH);
		rename(LOG_PATH, lognamebak);
		log = fopen(LOG_PATH, "wb");
		if (NULL == log) {
			printf("fopen() for [%s] failed, errno = [%d][%s].\n", LOG_PATH, errno, strerror(errno));
			return -3;
		}
	}

	char date[128] = {0};
	UnionGetAscSystemDateTimeWithMillsec(date);
	if (NULL == specified_procname) {
		fputc('\n', log);
	}
	fputs(date, log);
	fputc('\n', log);

	char procname[128] = {0};
	int vmsize = 0;
	int vmrss = 0;

	for (struct dirent* de = readdir(dir_proc); de != NULL; de = readdir(dir_proc)) {
		if (DT_DIR != de->d_type) {
			continue;
		}

		if (UnionIsDigitStr(de->d_name) == 0) {
			continue;
		}

		const int pid = atoi(de->d_name);

		if (UnionGetProcInfoByStatus(pid, procname, sizeof(procname), &vmsize, &vmrss) < 0) {
			printf("UnionGetProcInfoByStatus() for [%d] failed.\n", pid);
			continue;
		}

		UnionGetProcNameByCmdline(pid, procname, sizeof(procname));
		
		if (specified_procname != NULL && strcmp(specified_procname, procname) != 0) {
			continue;
		}
		fprintf(log, "%-60s%8d(PID)%16d(RSS, kB)%16d(VSZ, kB)\n", procname, pid, vmrss, vmsize);
	}
    return 0;
}

int main() {
	int interval_time = 0;
	printf("Please input interval_time: ");
	scanf("%d", &interval_time);
	char specified_flag = 0x00;
	char specified_procname[256] = {0};
	printf("Whether to specify a program name(Y/other): ");
	while (getchar() != '\n') {}
	scanf("%c", &specified_flag);
	if ('Y' == specified_flag) {
		printf("Please input specified program name: ");
		scanf("%s", specified_procname);
	}
	while (1) {
		if ('Y' == specified_flag) {
			UnionGetAllProcUseMem(specified_procname);
		}
		else {
			UnionGetAllProcUseMem(NULL);
		}
		sleep(interval_time);
	}
	
	return 0;
}
```



# 网络

## 网络流量

> 通过解析 /proc/net/dev 文件实现

```c
void func() {
    FILE *fp = fopen("/proc/net/dev", "r");
    char dev[] = "eth3";
    while (fgets(buffer, sizeof(buffer), fp) != NULL)
    {
        if (strstr(buffer, dev) == NULL)
        {
            continue;
        }
        if (sscanf(buffer, "%*s %ld %*d %*d %*d %*d %*d %*d %*d %ld %*d %*d %*d %*d %*d %*d %*d", &tmp_read_bytes, &tmp_write_bytes) == 2)
        {
            read_bytes = tmp_read_bytes;
			write_bytes = tmp_write_bytes;
            break;
        }
    }
}
```



## 网速

```cpp
void UnionUpdateHsmSharedMemNetSpeed()
{
	int status = 0;
	FILE *fp = NULL;
	char buffer[512] = {0};

	int read_speeds = 0;
	int write_speeds = 0;

	long read_bytes = 0L;
	long write_bytes = 0L;
	long tmp_read_bytes = 0L;
	long tmp_write_bytes = 0L;
	long last_read_bytes = 0L;
	long last_write_bytes = 0L;

	char dev[16][32] = {0};
	const int dev_num = (getIfaceNum() <= 0 ? 4 : getIfaceNum());
	for (int i = 0; i < dev_num; i++)
	{
		snprintf(dev[i], sizeof(dev[i]), "eth%d", i);
	}

	while (1)
	{
		fp = fopen("/proc/net/dev", "r");
		if (NULL == fp)
		{
			UnionUserErrLog("in UnionGetNetInfo:: fopen() failed, errno = [%d][%s].\n", errno, strerror(errno));
			continue;
		}

		read_bytes = 0L;
		write_bytes = 0L;

		memset(buffer, 0, sizeof(buffer));
		while (fgets(buffer, sizeof(buffer), fp) != NULL)
		{
			status = 0;

			for (int i = 0; i < dev_num; i++)
			{
				if (strstr(buffer, dev[i]) != NULL)
				{
					status = 1;
					break;
				}
			}

			if (status && sscanf(buffer, "%*s %ld %*d %*d %*d %*d %*d %*d %*d %ld %*d %*d %*d %*d %*d %*d %*d", &tmp_read_bytes, &tmp_write_bytes) == 2)
			{
				read_bytes += tmp_read_bytes;
				write_bytes += tmp_write_bytes;
			}
			memset(buffer, 0, sizeof(buffer));
		}
		fclose(fp);

		read_speeds = (read_bytes - last_read_bytes) / 1024;
		write_speeds = (write_bytes - last_write_bytes) / 1024;

		last_read_bytes = read_bytes;
		last_write_bytes = write_bytes;
		sleep(1);
	}
}
```



# 磁盘

## 磁盘流量

> 通过解析 /proc/diskstats 文件

```c
void func() {
    FILE *fp = fopen("/proc/diskstats", "r");
    char dev[] = "sda";
    while (fgets(buffer, sizeof(buffer), fp) != NULL)
    {
        ptr = strstr(buffer, dev);
        if (NULL == ptr || (ptr[strlen(dev)] >= '0' && ptr[strlen(dev)] <= '9'))
        {
            memset(buffer, 0, sizeof(buffer));
            continue;
        }
        sscanf(buffer, "%*d %*d %*s %*d %*d %ld %*d %*d %*d %ld", &read_blocks, &write_blocks);
 		read_bytes = read_blocks * block_size;
        write_bytes = write_blocks * block_size;       
        break;
    }
}
```



## 磁盘io速率

```c
void UnionUpdateHsmSharedMemIOSpeed()
{
	FILE *fp = NULL;
	char *ptr = NULL;
	char path[256] = {0};
	char buffer[256] = {0};
	const char dev[] = "sda";
	int block_size = 0;
	long read_blocks = 0L;
	long write_blocks = 0L;
	long read_bytes = 0L;
	long write_bytes = 0L;
	long last_read_bytes = 0L;
	long last_write_bytes = 0L;

	int read_speeds = 0;
	int write_speeds = 0;

	// 获取扇区大小
	snprintf(path, sizeof(path), "/sys/block/%s/queue/hw_sector_size", dev);
	fp = fopen(path, "r");
	if (NULL == fp)
	{
		UnionUserErrLog("in UnionUpdateHsmSharedMemIOSpeed:: fopen() for [%s] failed, errno = [%d][%s].\n", path, errno, strerror(errno));
		block_size = 512; // 默认值
	}
	else
	{
		fscanf(fp, "%d", &block_size);
		fclose(fp);
		fp = NULL;
	}

	while (1)
	{
		fp = fopen("/proc/diskstats", "r");
		if (NULL == fp)
		{
			continue;
		}

		read_bytes = 0L;
		write_bytes = 0L;
		memset(buffer, 0, sizeof(buffer));

		while (fgets(buffer, sizeof(buffer), fp) != NULL)
		{
			ptr = strstr(buffer, dev);
			if (NULL == ptr || (ptr[strlen(dev)] >= '0' && ptr[strlen(dev)] <= '9'))
			{
				memset(buffer, 0, sizeof(buffer));
				continue;
			}
			sscanf(buffer, "%*d %*d %*s %*d %*d %ld %*d %*d %*d %ld", &read_blocks, &write_blocks);
			read_bytes = read_blocks * block_size;
			write_bytes = write_blocks * block_size;
			memset(buffer, 0, sizeof(buffer));
			break;
		}
		fclose(fp);
		fp = NULL;

		read_speeds = (read_bytes - last_read_bytes) / 1024;
		write_speeds = (write_bytes - last_write_bytes) / 1024;
		
		last_read_bytes = read_bytes;
		last_write_bytes = write_bytes;
		sleep(1);
	}
}
```



# epoll

>  epoll 全称 eventpoll，是 linux 内核实现IO多路转接/复用（IO multiplexing）的一个实现。IO多路转接的意思是在一个操作里同时监听多个输入输出源，在其中一个或多个输入输出源可用的时候返回，然后对其的进行读写操作。epoll是select和poll的升级版，相较于这两个前辈，epoll改进了工作方式，因此它更加高效。

1. 对于待检测集合select和poll是基于线性方式处理的，epoll是基于红黑树来管理待检测集合的。
2. select和poll每次都会线性扫描整个待检测集合，集合越大速度越慢，epoll使用的是回调机制，效率高，处理效率也不会随着检测集合的变大而下降
3. select和poll工作过程中存在内核/用户空间数据的频繁拷贝问题，在epoll中内核和用户区使用的是共享内存（基于mmap内存映射区实现），省去了不必要的内存拷贝。
4. 程序猿需要对select和poll返回的集合进行判断才能知道哪些文件描述符是就绪的，通过epoll可以直接得到已就绪的文件描述符集合，无需再次检测
	使用epoll没有最大文件描述符的限制，仅受系统中进程能打开的最大文件数目限制

当多路复用的文件数量庞大、IO流量频繁的时候，一般不太适合使用select()和poll()，这种情况下select()和poll()表现较差，推荐使用epoll()。



## 函数接口

```c
#include <sys/epoll.h>

// 创建epoll实例，通过一棵红黑树管理待检测集合
/**
函数参数 size：在Linux内核2.6.8版本以后，这个参数是被忽略的，只需要指定一个大于0的数值就可以了。
函数返回值：
    失败：返回-1
    成功：返回一个有效的文件描述符，通过这个文件描述符就可以访问创建的epoll实例了
*/
int epoll_create(int size);


// 联合体, 多个变量共用同一块内存        
typedef union epoll_data {
 	void        *ptr;
	int          fd;	// 通常情况下使用这个成员, 和epoll_ctl的第三个参数相同即可
	uint32_t     u32;
	uint64_t     u64;
} epoll_data_t;
struct epoll_event {
	uint32_t     events;      /* Epoll events */
	epoll_data_t data;        /* User data variable */
};
// 管理红黑树上的文件描述符(添加、修改、删除)
/*
参数
    epfd：epoll_create() 函数的返回值，通过这个参数找到epoll实例
    op：这是一个枚举值，控制通过该函数执行什么操作
        EPOLL_CTL_ADD：往epoll模型中添加新的节点
        EPOLL_CTL_MOD：修改epoll模型中已经存在的节点
        EPOLL_CTL_DEL：删除epoll模型中的指定的节点
    fd：文件描述符，即要添加/修改/删除的文件描述符
    event：epoll事件，用来修饰第三个参数对应的文件描述符的，指定检测这个文件描述符的什么事件
        events：委托epoll检测的事件
            EPOLLIN：读事件, 接收数据, 检测读缓冲区，如果有数据该文件描述符就绪
            EPOLLOUT：写事件, 发送数据, 检测写缓冲区，如果可写该文件描述符就绪
            EPOLLERR：异常事件
        data：用户数据变量，这是一个联合体类型，通常情况下使用里边的fd成员，用于存储待检测的文件描述符的值，在调用epoll_wait()函数的时候这个值会被传出。

函数返回值：
    失败：返回-1
    成功：返回0
*/
int epoll_ctl(int epfd, int op, int fd, struct epoll_event *event);


// 检测epoll树中是否有就绪的文件描述符
/*
函数参数：
    epfd：epoll_create() 函数的返回值, 通过这个参数找到epoll实例
    events：传出参数, 这是一个结构体数组的地址, 里边存储了已就绪的文件描述符的信息
    maxevents：修饰第二个参数, 结构体数组的容量（元素个数）
    timeout：如果检测的epoll实例中没有已就绪的文件描述符，该函数阻塞的时长, 单位ms 毫秒
        0：函数不阻塞，不管epoll实例中有没有就绪的文件描述符，函数被调用后都直接返回
        大于0：如果epoll实例中没有已就绪的文件描述符，函数阻塞对应的毫秒数再返回
        -1：函数一直阻塞，直到epoll实例中有已就绪的文件描述符之后才解除阻塞

函数返回值：
    成功：
        等于0：函数是阻塞被强制解除了, 没有检测到满足条件的文件描述符
        大于0：检测到的已就绪的文件描述符的总个数
    失败：返回-1
*/
int epoll_wait(int epfd, struct epoll_event * events, int maxevents, int timeout);
```



## 操作步骤

```cpp
// 创建监听的套接字
int lfd = socket(AF_INET, SOCK_STREAM, 0);

// 设置端口复用（可选）
int opt = 1;
setsockopt(lfd, SOL_SOCKET, SO_REUSEADDR, &opt, sizeof(opt));

// 使用本地的IP与端口和监听的套接字进行绑定
int ret = bind(lfd, (struct sockaddr*)&serv_addr, sizeof(serv_addr));

// 给监听的套接字设置监听
listen(lfd, 128);

// 创建epoll实例对象
int epfd = epoll_create(100);

// 将用于监听的套接字添加到epoll实例中
struct epoll_event ev;
ev.events = EPOLLIN;    // 检测lfd读读缓冲区是否有数据
ev.data.fd = lfd;
int ret = epoll_ctl(epfd, EPOLL_CTL_ADD, lfd, &ev);

// 检测添加到epoll实例中的文件描述符是否已就绪，并将这些已就绪的文件描述符进行处理
int num = epoll_wait(epfd, evs, size, -1);

// 如果是监听的文件描述符，和新客户端建立连接，将得到的文件描述符添加到epoll实例中
int cfd = accept(curfd, NULL, NULL);
ev.events = EPOLLIN;
ev.data.fd = cfd;
// 新得到的文件描述符添加到epoll模型中, 下一轮循环的时候就可以被检测了
epoll_ctl(epfd, EPOLL_CTL_ADD, cfd, &ev);

// 如果是通信的文件描述符，和对应的客户端通信，如果连接已断开，将该文件描述符从epoll实例中删除
int len = recv(curfd, buf, sizeof(buf), 0);
if (len == 0) {
    // 将这个文件描述符从epoll模型中删除
    epoll_ctl(epfd, EPOLL_CTL_DEL, curfd, NULL);
    close(curfd);
}
else if(len > 0) {
    send(curfd, buf, len, 0);
}
```



## 示例代码

```cpp
#include <cstdio>
#include <cerrno>
#include <cstdlib>
#include <cstring>

#include <unistd.h>
#include <arpa/inet.h>
#include <sys/stat.h>
#include <sys/types.h>
#include <sys/socket.h>
#include <sys/epoll.h>

int main() {
    // 创建监听套接字
    int lfd = socket(AF_INET, SOCK_STREAM, 0);
    if (-1 == lfd) {
        std::printf("in %s::%d:: socket() fail, errno = [%d][%s].\n", __FUNCTION__, __LINE__, errno, std::strerror(errno));
        std::exit(-1);
    }

    // 设置端口复用
    int opt = 1;
    setsockopt(lfd, SOL_SOCKET, SO_REUSEADDR, &opt, sizeof(opt));

    // 使用本地ip与端口和监听套接字进行绑定
    struct sockaddr_in addr;
    std::memset(&addr, 0, sizeof(addr));
    addr.sin_family = AF_INET;
    addr.sin_port = htons(9999);
    addr.sin_addr.s_addr = htonl(INADDR_ANY);
    int ret = bind(lfd, (struct sockaddr*)&addr, sizeof(addr));
    if (-1 == ret) {
        std::printf("in %s::%d:: bind() fail, errno = [%d][%s].\n", __FUNCTION__, __LINE__, errno, std::strerror(errno));
        std::exit(-1);
    }

    // 将套接字设置为监听
    ret = listen(lfd, 256);
    if (-1 == ret) {
        std::printf("in %s::%d:: listen() fail, errno = [%d][%s].\n", __FUNCTION__, __LINE__, errno, std::strerror(errno));
        std::exit(-1);
    }

    // 创建epoll实例
    int epfd = epoll_create(128);
    if (-1 == epfd) {
        std::printf("in %s::%d:: epoll_create() fail, errno = [%d][%s].\n", __FUNCTION__, __LINE__, errno, std::strerror(errno));
        std::exit(-1);
    }

    // 将监听实例添加到epoll中
    struct epoll_event ev;
    std::memset(&ev, 0, sizeof(ev));
    ev.events = EPOLLIN;    // 检测sock读缓冲区是否有数据
    ev.data.fd = lfd;
    ret = epoll_ctl(epfd, EPOLL_CTL_ADD, lfd, &ev);
    if (-1 == ret) {
        std::printf("in %s::%d:: epoll_ctl() fail, errno = [%d][%s].\n", __FUNCTION__, __LINE__, errno, std::strerror(errno));
        std::exit(-1);
    }

    struct epoll_event evs[1024];
    while (1) {
        const int num = epoll_wait(epfd, evs, sizeof(evs)/sizeof(evs[0]), -1); // -1表示一直阻塞
        std::printf("in %s::%d:: num = [%d].\n", __FUNCTION__, __LINE__, num);
        for (int i = 0; i < num; i++) {
            const int fd = evs[i].data.fd;
            if (fd == lfd) {
                int cfd = accept(fd, NULL, NULL);
                std::memset(&ev, 0, sizeof(ev));
                ev.events = EPOLLIN;    // 检测sock读缓冲区是否有数据
                ev.data.fd = cfd;
                ret = epoll_ctl(epfd, EPOLL_CTL_ADD, cfd, &ev);
                if (-1 == ret) {
                    std::printf("in %s::%d:: epoll_ctl() fail, errno = [%d][%s].\n", __FUNCTION__, __LINE__, errno, std::strerror(errno));
                    std::exit(-1);
                }
                continue;
            }
            // fd, 操作fd
            char buf[1024] = {0};
            const int recvlen = recv(fd, buf, sizeof(buf), 0);
            if (-1 == recvlen) {
                std::printf("in %s::%d:: recv() fail, errno = [%d][%s].\n", __FUNCTION__, __LINE__, errno, std::strerror(errno));
                std::exit(-1);
            }
            else if (0 == recvlen) { // client disconnect
                std::printf("in %s::%d:: recv() fail, errno = [%d][%s], client disconnect.\n", __FUNCTION__, __LINE__, errno, std::strerror(errno));
                // 先删除
                epoll_ctl(epfd, EPOLL_CTL_DEL, fd, NULL);
                // 后关闭
                close(fd);
                continue;
            }
            std::printf("recv = [%s].\n", buf);

            std::memset(buf, 0, sizeof(buf));
            snprintf(buf, sizeof(buf), "Hello world.\n");
            
        }
    }

    // 检测添加到epoll实例中的文件描述符是否已就绪，并将这些已就绪的文件描述符进行处理
    
    return 0;
}
```



# 多进程

## fork子进程

```cpp
#include <unistd.h>

int main() {
    pid_t pid = fork();
    if (pid == 0) { // child proc
        ;
    }
    else if (pid > 0) { // parent proc
        ;
    }
    else { // fail
        
    }
}
```

