# 前言

1. CMake是一个开源的、跨平台的自动化构建工具，可以通过CMake管理项目。
2. CMake不是包管理工具。CMake并不只支持C/C++。
3. CMake会根据编译器的类型来决定是否生成Makefile。



# 流程

1. Configure -> 编写 CMakeLists.txt 文件

```cmake
# 编写 CMakeList.txt 文件
cmake_minimum_required(VERSION 3.20) # 指定最小版本
project(Hello) # 项目名
add_executable(Hello hello.cpp) # 由源文件生成一个可执行的程序
```



2. Generate -> 例如生成makefile

```sh
rm -rf build

# cmake -B 想生成的目录
cmake -B build

# 参数
# -G指定使用什么方式来Generate编译文件
cmake -B build -G "Unix Makefiles"
cmake -B build -G "Ninja"

# 指定编译器
cmake -B build -DCMAKE_CXX_COMPILER=clang++

# 指定文件
cmake -P *.cmake 			# 简单文件, 无法编译项目
cmake -B build/ -C *.cmake 	# 指定cmake文件
```



3. Build -> 编译链接，相当于执行make

```sh
# 生成可执行二进制文件
# cmake --build 上一步指定的文件
cmake --build build

# 如果是 -G "Unix Makefiles" Generate的makefile的话，其可执行文件位于 ./bulid/Hello
```



# 语法

> 用于 `CMakeLists.txt/*.cmake` 文件构建 cmake 文件。

1. 执行从源树 `CMakeLists.txt` 的根文件开始。
2. cmake 命令行工具：
   1. cmake
   2. ctest : 测试
   3. cpack
   4. cmake-gui : 可视化工具
   5. ccmake : 接口

```cmake
# 指定最小版本
cmake_minimum_required(VERSION 3.20)

# 输出信息
# 单行
message("hello")
# 多行
message("hello
 world")
message([[hello
 world]]) # 等同上一句
 
# 获取cmake中的信息
${VALUE_NAME}
# 例如
# 打印cmake版本号
message(${CMAKE_VERSION})

# 设置C++标准
set(CMAKE_CXX_STANDARD 11)
set(CMAKE_CXX_STANDARD_REQUIRED ON)

# 搜索源文件
file()

# 导出目录
${LIBRARY_OUTPUT_PATH}
```



## 常用语法

```cmake
# 指定最小版本
cmake_minimum_required(VERSION 3.20)

# 设置C++标准
set(CMAKE_CXX_STANDARD 11)
set(CMAKE_CXX_STANDARD_REQUIRED ON)

# 导出目录变量
# 库文件
${LIBRARY_OUTPUT_PATH}

# 添加子模块/子目录
add_subdirectory(dir_name)

# 添加可执行目标
add_executable(program_name filename.cpp)

# 添加包含子目录, 相当于 -I
target_include_directories(program_name PUBLIC inc_path)

# 生成库文件
add_library(lib_name STATIC/SHARED src_file.cpp) 

# 链接库文件
target_link_libraries(program_name PUBLIC lib_name)

# 添加一个宏定义 -D MY_MACRO=1
target_add_definitions(program_name PUBLIC MY_MACRO=1) 
 
# 添加编译器命令行选项
target_compile_options(program_name PUBLIC -fopenmp) 
 
# 添加要编译的源文件
target_sources(program_name PUBLIC hello.cpp other.cpp)
 
# 引进第三方库
# 1. 纯头文件引入
# 2. 作为子模块引入, 建立子文件, 编译为库文件, 最后链接
# 3. 使用系统中预安装的第三方库
find_package(fmt REQUIRED)
target_link_libraries(program_name PUBLIC fmt::fmt)

# 现代 CMake 认为一个包 (package) 可以提供多个库，又称组件 (components)，比如 TBB 这个包，就包含了 tbb, tbbmalloc, tbbmalloc_proxy 这三个组件。
find_package(TBB REQUIRED COMPONENTS tbb tbbmalloc REQUIRED)
target_link_libraries(myexec PUBLIC TBB::tbb TBB::tbbmalloc)
```



## 变量操作

1. cmake的变量分为两种
   1. cmake提供，类似于cpp的预定义宏。
   2. 自定义
2. 区分大小写
3. 在存储时都是字符串。
4. 获得变量：

```cmake
${value_name}
```



5. **set/unset方法**：
   1. 创建变量
   2. 给一个变量设置多个值
   3. 变量内部存储时使用 `;` 分割，但显示时只进行连接操作；不显示。

```cmake
set(<variable> <value>...[PARENT_SCOPE])

# 例如：
# 设置单个值
set(Var1 "YYYY")
message(${Var1})	# YYYY

# 设置多个值
# 设置多个值
set(LISTVALUE a1 a2)
message(${LISTVALUE})	# a1a2

# 对变量重新赋值
set(LISTVALUE a1;a2;a3)
message(${LISTVALUE})	# a1a2a3

# 系统环境变量
message($ENV{PATH}) # 相当于 echo $PATH

# 创建环境变量, 作用域为这个cmake项目
set(ENV{CXX} "g++")	# 相当于export CXX=g++，但作用域为这个cmake项目

unset(ENV{CXX})		# 取消设置/赋值
```



6. **list方法**：
   1. 创建变量

```cmake
# 添加元素
# 语法: list(APPEND <list> [<elem>...])
list(APPEND port p1 p2 p3)	
message(${port})	# p1p2p3

# 获取元素个数
# 语法: list(LENGTH <list> <output variable>)
list(LENGTH port len)
message(${len})	# 3

# 查找元素，返回索引
# 语法: list(FIND <list> <value> <out-var>)
list(FIND port a2 index)
message(${index})	# -1

# 移出元素
# 语法: list(REMOVE_ITEM <list> <value> [value...])
list(REMOVE_ITEM port p2)
message(${port})	# p1p3

# 在index位置插入
# 语法: list(INSERT <list> <index> [<elem>...])
list(INSERT port 1 ab)
message(${port})	# p1abp3

# 反转list
# 语法: list(REVERSE <list>)
list(REVERSE port)
message(${port})	# p3abp1

# 排序list - 字符串排序
# 语法: list(SORT <list> [...])
list(SORT port)
message(${port})	# abp1p3
```



## 流程控制

1. if 条件流程控制

```cmake
# 1, ON, YES, TRUE, Y, 非0数
# 0, OFF, NO, FALSE, N, IGNORE, NOTFOUND, 空字符串, 或以 suffix 结尾 -NOTFOUND 则为假
if (condtition) 
elseif (condition)
else ()
endif ()

# NOT, AND, OR
# LESS, EQUAL, GREATER
# EXIST: 判断文件或目录是否存在
# COMMAND:  如果给定的名称是命令、宏或者函数这类可被调用的对象，则返回真

# such as
set(VARBOOL TRUE)

if (VARBOOL)
    message("TRUE") #
else ()
    message("FALSE")
endif ()

# NOT
if (NOT VARBOOL)	# 取反
    message("TRUE")
else ()
    message("FALSE")	# 
endif ()

# OR
if (NOT VARBOOL OR VARBOOL)
    message("TRUE")		# 
else ()
    message("FALSE")
endif ()

# AND
if (NOT VARBOOL AND VARBOOL)
    message("TRUE")
else ()
    message("FALSE")	#
endif ()

# LESS 
if (1 LESS 2)
    message("1 < 2") # 
endif ()

# EQUAL
if (1 EQUAL 1)
	message("1 == 1")
endif ()

# GREATER
if (2 GREATER 1) 
    message ("2 > 1")
endif ()
```



2. loop循环流程控制，FOR，WHILE

   1. break

   1. continue

```cmake
# foreach
foreach (<loop_var> RANGE <max>)
	<>
endforeach ()

# such as
foreach(VAR RANGE 3)
    message(${VAR})	# 0 1 2 3
endforeach()

######################################

foreach (<loop_var> RANGE <min> <max> [<step>])

######################################

foreacg (<loop_var> IN [LISTS <lists>][ITEMS <items>])

# such as
# 使用较多
set(MY_LIST 1 2 3)
foreach (VAR IN LISTS MY_LIST ITEMS 4 f) # MY_LIST 加上 ITEMS 后面的元素
    message(${VAR})	# 1 2 3 4 f
endforeach ()

######################################

set(L1 one two three four)
set(L2 1 2 3 4 5)
foreach (num IN ZIP_LISTS L1 L2)
    message("Word = ${num_0}, num = ${num_1}")
endforeach ()

# Word = one, num = 1
# Word = two, num = 2
# Word = three, num = 3
# Word = four, num = 4
# Word = , num = 5

######################################

# while
while (condition)
	<>
endwhile ()
```



## 函数

```cmake
# 定义函数的语法
function(<name> [<argumemt>...])
	<command>
endfunction()

# such as
cmake_minimum_required(VERSION 3.20.0)

function(MyFunc FirstArg)
	# CMAKE_CURRENT_FUNCTION：当前函数名
    message("MyFunc Name: ${CMAKE_CURRENT_FUNCTION}")
    message("FirstArg: ${FirstArg}")
    set(FirstArg, "New Vaule")
    message("FirstArg: argin ${FirstArg}")
    # ARGV0, 传入的第一个参数，以此类推
    message("ARGV0 ${ARGV0}")	
    message("ARGV1 ${ARGV1}")
    message("ARGV2 ${ARGV2}")
endfunction()


set(FirstArg "first value")
# 可以传入比函数声明更多数量的参数
MyFunc(${FirstArg}, "2 value")
message("not func FirstArg: ${FirstArg}")

############### 
# MyFunc Name: MyFunc
# FirstArg: first value,
# FirstArg: argin FirstArg,
# ARGV0 first value,
# ARGV1 2 value
# ARGV2 
# not func FirstArg: first value
```



## 作用域

1. 函数作用域：调用函数时，被调用函数会继承调用函数定义的变量的值，但对该变量的改变不会影响调用函数的变量。相当于值传递。

```cmake
cmake_minimum_required(VERSION 3.20.0)
project(scope)

function(OutFunc)
    message("-> OutFunc ${Var}")
    set(Var 2)
    InFunc()
    message("<- OutFunc ${Var}")
endfunction()

function(InFunc)
    message("-> InFunc ${Var}")
    set(Var 3)
    message("<- InFunc ${Var}")
endfunction()

set(Var 1)
message("-> Global Var = ${Var}")
OutFunc()
message("<- Global Var = ${Var}")

###################################

# -> Global Var = 1
# -> OutFunc 1
# -> InFunc 2
# <- InFunc 3
# <- OutFunc 2
# <- Global Var = 1
```



2. 文件夹作用域：当从 `add_subdirectory()` 命令执行嵌套目录中的 `CMakeLists.txt` 列表文件时，注意父 `CMakeLists.txt` 中的变量可以被子 `CMakeLists.txt` 使用。



## 宏

尽量不要写宏，会读就好，类似与c的`#define` 

```cmake
# 语法
macro(<name>[<argument>...])
	<commands>
endmacro()

# such as
macro(Test myVar)
    set(myVar "new value") # 创建一个新的myVar变量
    message("argument: ${myVar}")
endmacro()

set(myVar "First value")
message("myVar = ${myVar}")
Test("value")
message("myVar = ${myVar}")

####################### 
# myVar = First value
# argument: value
# myVar = new value # 变量被reset了
```



# 构建项目方式

## 直接写入源码路径

- `add_executable` 中直接写入相对路径。
- 在源码中引入头文件时需要写相对路径。

```cmake
# CMakeLists.txt
# main.cpp
# animal
## dog.h
## dog.cpp

cmake_minimum_required(VERSION 3.20.0)
project(Animal CXX)
set(CMAKE_CXX_STANDARD 17)

add_executable(Animal main.cpp animal/dog.cpp)
```



## 调用子目录cmake方法

- `include` 方法可以引入子目录中的 `cmake` 后缀的配置文件
- 将配置加入 `add_executable` 中。

```cmake
# CMakeLists.txt
# main.cpp
# animal
## animal.cmake
## dog.h
## dog.cpp
## cat.h
## cat.cpp

# animal.cmake
set(animal_source animal/dog.cpp animal/cat.cpp)

# CMakeLists.txt
cmake_minimum_required(VERSION 3.20.0)
project(Animal CXX)
set(CMAKE_CXX_STANDARD 17)

include(animal/animal.cmake)

add_executable(Animal main.cpp ${animal_source})
```



## CMakeLists嵌套

> 常用

- `target_include_directories` 头文件目录的声明。
- `target_link_libraries` 连接库文件。
- `add_subdirectory` 添加子目录。
- `add_library` 生成库文件，默认 `STATIC library`。

```cmake
# CMakeLists.txt
# main.cpp
# animal
## CMakeLists.txt
## dog.h
## dog.cpp
## cat.h
## cat.cpp

# animal/CMakeLists.txt
add_library(AnimalLib STATIC cat.cpp dog.cpp) # 生成静态库
target_include_directories(AnimalLib PUBLIC .) # 如果不希望让引用 AnimalLib 的可执行文件自动添加这个路径，把 PUBLIC 改为 PRIVATE即可。这就是它们的用途：决定一个属性要不要被link的时候传播

# CMakeLists.txt
cmake_minimum_required(VERSION 3.20.0)
project(Animal CXX)
set(CMAKE_CXX_STANDARD 17)

add_subdirectory(animal)

add_executable(Animal main.cpp)

target_link_libraries(Animal PUBLIC AnimalLib)

# target_include_directories(Animal PUBLIC "${PROJECT_SOURCE_DIR}/animal") # 子目录已添加，这里
```



## Object Library

`cmake version >= 3.12` ，实际是生成目标文件 `.o` .

- `add_library OBJECT`：
  - Object Library 是一个特殊类型的库类型，它将目标文件编译成一个库，但不会生成最终的链接文件。
  - 这意味着可以在后续的 `add_library()` 或 `add_executable()` 命令中，将 Object Librery 作为源文件进行链接，从而生成最终的可执行文件或库文件。
- 将 `target_include_directories` 移动到子 `CMakeLists.txt` 中。

```cmake
# CMakeLists.txt
# main.cpp
# animal
## CMakeLists.txt
## dog.h
## dog.cpp
## cat.h
## cat.cpp

# animal/CMakeLists.txt
add_library(AnimalLib OBJECT cat.cpp dog.cpp)
target_include_directories(AnimalLib PUBLIC .)

# CMakeLists.txt
cmake_minimum_required(VERSION 3.20.0)
project(Animal CXX)

add_subdirectory(animal)
add_executable(Animal main.cpp)
target_link_libraries(Animal PUBLIC AnimalLib)
```



# 库文件相关

动态库是有执行权限的，而静态库没有。



## 相关命令

```cmake
# 搜索源文件
file()


# 导出目录
${LIBRARY_OUTPUT_PATH}
```



## 静态库

1. 在连接阶段，会将汇编生成的目标文件 `.o` 与引用到的库一起链接打包到可执行文件中。因此对应的链接方式为静态链接。
2. 对函数库的连接是在编译时完成的。
3. 命名：`lib<name>.a/lib`
4. 生成：

```cmake
# 生成静态库命令
add_library(animal STATIC ${SRC}) # 生成静态库

# such as
# CMakeLists.txt
# src
## dog.cpp
## cat.cpp
# include
## cat.h
## dog.h

# CMakeLists.txt
cmake_minimum_required(VERSION 3.20.0)
project(Animal CXX)

# 寻找 ./src 目录下的cpp文件, 并存入 SRC 变量中，方便后续使用
file(GLOB SRC ${PROJECT_SOURCE_DIR}/src/*.cpp)

# 设置头文件路径
include_directories(${PROJECT_SOURCE_DIR}/include)

# 设置库文件输出路径
set(LIBRARY_OUTPUT_PATH ${PROJECT_SOURCE_DIR}/lib)

# 设置库属性和源文件
add_library(animal STATIC ${SRC})
```



5. 调用：
   1. 引入头文件
   2. 连接静态库
   3. 生成可执行二进制文件

```cmake
# such as
# CMakeLists.txt
# include
## cat.h
## dog.h
# a
## libanimal.a
# main.cpp

cmake_minimum_required(VERSION 3.20.0)
project(Animal CXX)

# 导入文件
include_directories(${PROJECT_SOURCE_DIR}/include)

# 连接静态库
# target_link_libraries()
# 指定库路径
link_directories(${PROJECT_SOURCE_DIR}/a)
# 指定静态库名称
link_libraries(animal)

# 生成二进制可执行文件
add_executable(a_app main.cpp)
```





## 动态库

1. 动态库不是在编译时被连接到目标文件中，而是运行时才被载入。
2. 静态库对空间的浪费是巨大的。
3. 命名：`lib<name>.so/ddl` 

4. 生成：

```cmake
# 命令
add_library(animal SHARED ${SRC}) # 生成动态库

# such as
# CMakeLists.txt
# src
## dog.cpp
## cat.cpp
# include
## cat.h
## dog.h

# CMakeLists.txt
cmake_minimum_required(VERSION 3.20.0)
project(Animal CXX)

# 寻找 ./src 目录下的cpp文件, 并存入 SRC 变量中，方便后续使用
file(GLOB SRC ${PROJECT_SOURCE_DIR}/src/*.cpp)

# 设置头文件路径
include_directories(${PROJECT_SOURCE_DIR}/include)

# 设置库文件输出路径
set(LIBRARY_OUTPUT_PATH ${PROJECT_SOURCE_DIR}/lib)

# 设置库属性和源文件
add_library(animal SHARED ${SRC})
```



5. 调用：
   1. 引入头文件
   2. 声明库目录
   3. 生成可执行二进制文件
   4. 连接动态库

```cmake
# such as
# CMakeLists.txt
# include
## cat.h
## dog.h
# so
## libanimal.so
# main.cpp

cmake_minimum_required(VERSION 3.20.0)
project(Animal CXX)

# 导入文件
include_directories(${PROJECT_SOURCE_DIR}/include)

# 连接动态库
# 指定库路径
link_directories(${PROJECT_SOURCE_DIR}/so)

add_executable(so_app main.cpp)

# 连接动态库
target_link_libraries(so_app PUBLIC animal)
```



# 与源文件交互

1. 通过模板来生成头文件，源文件引入头文件来进行交互。
2. 可以获取 cmake 的变量以及系统环境变量

```cmake
# 命令
configure_file()

# such as:
# 通过 config.h.in 文件生成 config.h 头文件
# CMakeLists.txt
# config.h.in
# main.cpp
# animal
## CMakeLists.txt
## dog.h
## dog.cpp
## cat.h
## cat.cpp

# ./animal/CMakeLists.txt
add_library(AnimalLib OBJECT cat.cpp dog.cpp)
target_include_directories(AnimalLib PUBLIC .)

# config.h.in:
#define CMAKE_CXX_VERSION ${CMAKE_CXX_STANDARD}

# CMakeLists.txt:
cmake_minimum_required(VERSION 3.20.0)
project(Animal CXX)

# 设置C++标准
set(CMAKE_CXX_STANDARD 11)
set(CMAKE_CXX_STANDARD_REQUIRED ON)

# 通过 ./config.h.in 文件生成 ./build/config.h 头文件
configure_file(config.h.in config.h)

add_subdirectory(animal)
add_executable(Animal main.cpp)
target_link_libraries(Animal PUBLIC AnimalLib)
target_include_directories(Animal PUBLIC "${PROJECT_BINARY_DIR}") # 包含该目录
```



# 条件编译

通过不同传入参数编译不同的文件

1. 用 `option` 定义变量
2. 在子 CMakeLists.txt 中根据变量 `ON` 还是 `OFF` 来修改 `src` 源文件以及 `target_compile_definitions`。
3. 修改源文件根据变量选择代码
4. 执行命令时 -D <变量> =ON/OFF 来进行条件编译。

```cmake
option(JN56 "RJ-" ON)

# code
#ifdef JN56
#else
#endif
```





`PUBLIC/INTERFACE/PRIVATE` 区别：

- PUBLIC 本目标需要用，依赖这个目标的其他目标也需要。
- INTERFACE 本目标不需要，依赖本目标的其他目标需要。
- PRIVATE 本目标需要，其他依赖这个目标的其他目标不需要。