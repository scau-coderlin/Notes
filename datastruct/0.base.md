# 算法

> 算法，是指特定的计算模型，旨在**解决某一信息处理问题而设计的一个指令序列**。

## 要素

1. 输入与输出：
   1. 待计算问题的任一实例，都需要以某种方式交给对应的算法，对所求解问题特定实例的这种描述统称为输入。
   2. 经计算和处理之后得到的信息，即针对输入问题实例的答案，称作输出。
2. 基本操作、确定性与可行性。
   1. 所谓确定性和可行性是指，算法应可描述为由若干语义明确的基本操作组成的指令序列，且每一基本操作在对应的计算模型中均可兑现。
   2. 具体地，一个算法满足确定性和可行性，当且仅当它可以通过程序设计语言精确的描述。
3. 有穷性与准确性；
   1. 任意算法都应在执行有限次基本操作之后终止并给出输出，此即所谓算法的有穷性。
   2. 进一步地，算法不仅应该迟早会终止，而且所给的输出还应该能够符合由问题本身在事先确定的条件，此即算法的正确性。
   3. 证明算法有穷性和正确性的一个重要技巧，就是从适当的角度审视整个计算过程。并找出其所具有的某种不变性和单调性。单调性是指，问题的规模会随着算法的不断推进不断递减。
4. 退化与鲁棒性：能应对极端输入。
5. 重用性：可适用不同类型基本元素。
6. 可计算性。
7. 难解性。
8. 计算效率：研究和归纳算法设计与实现过程中的一般性规律和技巧。
9. 数据结构。



## 时间复杂度

1. 将时间复杂度理解为算法中各条指令的执行时间之和。
2. 从保守估计的角度出发，在规模为n的所有输入中，选择执行时间最长者作为T(n)，并以T(n)度量该算法的时间复杂度。
3. 渐进复杂度，当规模n足够大时，只需保留最高项以即其系数可以省略。



# 递归

1. 在**线性递归**算法中，若**递归调用在递归实例中恰好以最后一步**操作的形式出现，且递归最后终止于该递归调用语句，则称为尾递归。可进行以下转换：

```cpp
// 递归函数入口
void _reverse(int *A, int lo, int hi)
{
	if (lo < hi)
	{
		swap(A[lo], A[hi]);
		reverse(A, lo+1, hi-1);
	}
}

#if 0
next:
	if (lo < hi)
	{
		swap(A[lo], A[hi]);
		lo++, hi--;
		goto next;
	}
#else
	while (lo < hi)
	{
		swap(A[lo], A[hi]);
		lo++, hi--;
	}
#endif
```

